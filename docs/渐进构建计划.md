# Franka DS - ä¸‰é˜¶æ®µæ¸è¿›æ„å»ºè®¡åˆ’ (ä¿®æ­£ç‰ˆ)

## ğŸ“‹ æ€»ä½“æ¶æ„æ¦‚è¿°

åŸºäºè®ºæ–‡ã€Šæ¥è§¦ä»»åŠ¡ä¸­çš„è¿åŠ¨å’ŒåŠ›ç”Ÿæˆï¼šä¸€ç§åŠ¨åŠ›å­¦ç³»ç»Ÿæ–¹æ³•ã€‹çš„æ ¸å¿ƒå‘ç°ï¼š**DSç³»ç»Ÿæ˜¯çº¯é€Ÿåº¦æ§åˆ¶ï¼Œæ— éœ€ä½ç½®ç§¯åˆ†**ã€‚å°†ç°æœ‰çš„ä½ç½®æ§åˆ¶ç³»ç»Ÿå®Œå…¨è¿ç§»åˆ°DSé€Ÿåº¦æ§åˆ¶æ¡†æ¶ã€‚

```
é˜¶æ®µä¸€: DSçº¯é€Ÿåº¦æ§åˆ¶æ¡†æ¶ + Frankaé€Ÿåº¦æ¥å£é›†æˆ    ğŸ¯ å½“å‰ç›®æ ‡
é˜¶æ®µäºŒ: è¡¨é¢å­¦ä¹ ä¸æ³•å‘é‡ä¼°è®¡é›†æˆ                ğŸ“‹ è§„åˆ’é˜¶æ®µ  
é˜¶æ®µä¸‰: å®Œæ•´DSè°ƒåˆ¶ç®—æ³•ä¸å·¥ä¸šçº§ä¼˜åŒ–              ğŸ”® æœ€ç»ˆç›®æ ‡
```

---

## ğŸš€ é˜¶æ®µä¸€ï¼šDSçº¯é€Ÿåº¦æ§åˆ¶æ¡†æ¶ + Frankaé€Ÿåº¦æ¥å£é›†æˆ ğŸ¯

### 1.1 æ ¸å¿ƒæ¶æ„é‡æ–°è®¾è®¡

#### 1.1.0 DSç†è®ºä¼˜åŠ¿ä¸æ€§èƒ½æå‡è¯´æ˜ â­

**DSæ–¹æ³•ç›¸å¯¹ä¼ ç»ŸPDæ§åˆ¶çš„æ ¹æœ¬ä¼˜åŠ¿**ï¼š

```
ä¼ ç»ŸPDä½ç½®æ§åˆ¶ (æ—§ç³»ç»Ÿ):
  æ§åˆ¶ç›®æ ‡: ä½ç½®è¯¯å·® â†’ PDè°ƒèŠ‚ â†’ ä½ç½®è¾“å‡º
  åŠ›æ§åˆ¶ç­–ç•¥: é—´æ¥æ§åˆ¶ï¼ˆè°ƒæ•´Zè½´ä½ç½®æ¥æ§åˆ¶æ¥è§¦åŠ›ï¼‰
  æ‰°åŠ¨å¤„ç†: éœ€è¦é‡æ–°è§„åˆ’è½¨è¿¹ï¼Œå“åº”æ…¢
  çŠ¶æ€åˆ‡æ¢: éœ€è¦ç­‰å¾…æ—¶é—´ç¡®ä¿ç¨³å®šï¼ˆå¦‚10ç§’ç­‰å¾…ï¼‰

DSé€Ÿåº¦æ§åˆ¶ (æ–°ç³»ç»Ÿ):
  æ§åˆ¶ç›®æ ‡: å½“å‰çŠ¶æ€ â†’ DSè®¡ç®— â†’ é€Ÿåº¦è¾“å‡º  
  åŠ›æ§åˆ¶ç­–ç•¥: ç›´æ¥è°ƒåˆ¶é€Ÿåº¦ v_d = Î»*f(x) + (Î³_p*F_d/d1)*e1
  æ‰°åŠ¨å¤„ç†: ç¬æ—¶é‡æ–°è®¡ç®—ï¼Œè‡ªç„¶æ¢å¤
  çŠ¶æ€åˆ‡æ¢: æ— éœ€ç­‰å¾…ï¼Œç«‹å³å“åº”
```

**æ€§èƒ½æå‡é¢„æœŸ**ï¼š
- âœ… **å“åº”é€Ÿåº¦æå‡**ï¼šDSæ— éœ€ç­‰å¾…ç¨³å®šï¼Œç«‹å³å¯åŠ¨åŠ›åé¦ˆæ§åˆ¶
- âœ… **æ§åˆ¶ç²¾åº¦æå‡**ï¼šç›´æ¥é€Ÿåº¦è°ƒåˆ¶æ¯”é—´æ¥ä½ç½®æ§åˆ¶æ›´å‡†ç¡®
- âœ… **é²æ£’æ€§æå‡**ï¼šæ‰°åŠ¨åè‡ªåŠ¨æ¢å¤ï¼Œæ— éœ€é‡è§„åˆ’
- âœ… **ç†è®ºä¿è¯**ï¼šDSå…¨å±€æ¸è¿‘ç¨³å®šæ€§ï¼Œèƒ½é‡ç½æ— æºæ€§ä¿è¯

#### 1.1.1 è‡ªç”±ç©ºé—´ä¸æ¥è§¦ç©ºé—´ç»Ÿä¸€å‘é‡åœºè®¾è®¡ â­

**æ ¸å¿ƒæŒ‘æˆ˜**: å¦‚ä½•è®¾è®¡ç»Ÿä¸€çš„å‘é‡åœºå®ç°ä»èµ·ç‚¹â†’ç›®æ ‡ç‚¹â†’æ¥è§¦â†’åŠ›æ§åˆ¶è¿åŠ¨çš„æ— ç¼è¡”æ¥ï¼Ÿ

##### **DSå‘é‡åœºåˆ†å±‚è®¾è®¡**
```python
# ä¼ªä»£ç ï¼šå‘é‡åœºç»Ÿä¸€è®¡ç®—æ¡†æ¶
def computeUnifiedDS(current_position, robot_state, surface_info):
    """
    ç»Ÿä¸€çš„DSå‘é‡åœºè®¡ç®—ï¼Œè‡ªåŠ¨å¤„ç†è‡ªç”±ç©ºé—´ä¸æ¥è§¦ç©ºé—´åˆ‡æ¢
    """
    # 1. åˆ¤æ–­å½“å‰æ‰€åœ¨ç©ºé—´
    contact_state = detectContactState(robot_state.force, surface_info)
    
    if contact_state == FREE_SPACE:
        # è‡ªç”±ç©ºé—´ï¼šçº¿æ€§æ”¶æ•› + é¿éšœ
        ds_velocity = computeFreeSpaceDS(current_position)
    elif contact_state == APPROACHING_SURFACE:
        # æ¥è¿‘è¡¨é¢ï¼šæ··åˆDSï¼ˆæ¥è¿‘+ä¸‹æ¢ï¼‰
        ds_velocity = computeApproachingDS(current_position, surface_info)
    elif contact_state == IN_CONTACT:
        # æ¥è§¦ç©ºé—´ï¼šåŠ›è°ƒåˆ¶DS
        ds_velocity = computeContactDS(current_position, robot_state.force)
    
    # 2. ç»Ÿä¸€çš„æ‰°åŠ¨æ¢å¤å¤„ç†
    ds_velocity = applyDisturbanceRecovery(ds_velocity, external_force)
    
    # 3. èƒ½é‡ç½æ— æºæ€§çº¦æŸ
    safe_velocity = energyTank.constrainVelocity(ds_velocity)
    
    return safe_velocity
```

##### **è‡ªç”±ç©ºé—´å‘é‡åœºè®¾è®¡**
```cpp
// ä¼ªä»£ç ï¼šè‡ªç”±ç©ºé—´DSå®ç°æ‰°åŠ¨æ¢å¤
class FreeSpaceDS : public DSPrimitive {
private:
    Vector3d target_position_;
    Vector3d approach_point_;    // è¡¨é¢ä¸Šæ–¹çš„æ¥è¿‘ç‚¹
    Matrix3d lambda_;           // æ”¶æ•›ç‡çŸ©é˜µ
    
public:
    Vector3d computeVelocity(const Vector3d& current_pos, 
                           const ExternalForce& disturbance) override {
        
        // 1. åŸºç¡€çº¿æ€§DSï¼šx' = -Î»(x - x*)
        Vector3d error = target_position_ - current_pos;
        Vector3d nominal_ds = -lambda_ * error;
        
        // 2. æ‰°åŠ¨æ¢å¤æœºåˆ¶ï¼ˆDSç†è®ºæ ¸å¿ƒä¼˜åŠ¿ï¼‰
        if (disturbance.magnitude() > threshold_) {
            // DSè‡ªç„¶æ¢å¤ï¼šæ— éœ€é‡è§„åˆ’ï¼Œç›´æ¥åŸºäºå½“å‰ä½ç½®é‡æ–°è®¡ç®—
            // è¿™æ˜¯DSç›¸æ¯”è½¨è¿¹è·Ÿè¸ªçš„æœ€å¤§ä¼˜åŠ¿ï¼
            ROS_INFO("æ£€æµ‹åˆ°æ‰°åŠ¨ï¼ŒDSè‡ªåŠ¨æ¢å¤åˆ°ç›®æ ‡");
            // DSä¼šè‡ªåŠ¨ä»æ–°ä½ç½®æ”¶æ•›åˆ°ç›®æ ‡ï¼Œæ— éœ€é¢å¤–å¤„ç†
        }
        
        // 3. æ¥è¿‘è¡¨é¢æ—¶çš„æ··åˆå‘é‡åœº
        double distance_to_target = error.norm();
        if (distance_to_target < APPROACH_THRESHOLD) {
            // åˆ‡æ¢åˆ°æ¥è¿‘æ¨¡å¼ï¼šæ°´å¹³æ¥è¿‘ + å‚ç›´ä¸‹æ¢
            Vector3d horizontal_approach = computeHorizontalApproach(current_pos);
            Vector3d vertical_descent = computeVerticalDescent(current_pos);
            
            // æƒé‡æ··åˆï¼šè·ç¦»ç›®æ ‡è¶Šè¿‘ï¼Œä¸‹æ¢åˆ†é‡è¶Šå¤§
            double descent_weight = smoothTransition(distance_to_target);
            nominal_ds = (1.0 - descent_weight) * horizontal_approach + 
                        descent_weight * vertical_descent;
        }
        
        return nominal_ds;
    }
    
private:
    Vector3d computeHorizontalApproach(const Vector3d& pos) {
        // æ°´å¹³æ¥è¿‘ï¼šåªåœ¨xyå¹³é¢å†…æ”¶æ•›
        Vector3d horizontal_error = target_position_.head<2>() - pos.head<2>();
        return Vector3d(horizontal_error.x(), horizontal_error.y(), 0);
    }
    
    Vector3d computeVerticalDescent(const Vector3d& pos) {
        // å‚ç›´ä¸‹æ¢ï¼šæ’å®šé€Ÿåº¦å‘ä¸‹
        return Vector3d(0, 0, -DESCENT_VELOCITY);  // -1mm/s
    }
    
    double smoothTransition(double distance) {
        // å¹³æ»‘è¿‡æ¸¡å‡½æ•°ï¼šè·ç¦»è¶Šè¿‘ï¼Œä¸‹æ¢æƒé‡è¶Šå¤§
        return 1.0 - exp(-distance / TRANSITION_SCALE);
    }
  };
  ```

##### **æ¥è§¦ç©ºé—´å‘é‡åœºè®¾è®¡**
```cpp
// ä¼ªä»£ç ï¼šæ¥è§¦ç©ºé—´åŠ›è°ƒåˆ¶DS
class ContactDS : public DSPrimitive {
private:
    Vector3d circle_center_;
    double target_force_;
    double radius_;
    
public:
    Vector3d computeVelocity(const Vector3d& current_pos,
                           const ForceReading& contact_force) override {
        
        // 1. åŸºç¡€åœ†å‘¨è¿åŠ¨DSï¼ˆå‚è€ƒSurfacePolishing.cppï¼‰
        Vector3d tangential_ds = computeCircularMotion(current_pos);
        
        // 2. æ³•å‘åŠ›è°ƒåˆ¶ï¼ˆè®ºæ–‡æ ¸å¿ƒï¼šåŠ›åé¦ˆé›†æˆï¼‰
        Vector3d normal_vector = estimateSurfaceNormal(contact_force);
        double force_error = target_force_ - contact_force.magnitude();
        
        // 3. åŠ›è°ƒåˆ¶DSå…¬å¼ï¼ˆå‚è€ƒè®ºæ–‡Eq.7ï¼‰
        // v_d = v_tangential + (Î³_p * F_d / d1) * n
        double force_modulation = computeForceModulation(force_error);
        Vector3d force_ds = force_modulation * normal_vector;
        
        // 4. æœ€ç»ˆè°ƒåˆ¶DS
        Vector3d modulated_ds = tangential_ds + force_ds;
        
        return modulated_ds;
    }
    
private:
    Vector3d computeCircularMotion(const Vector3d& pos) {
        // å‚è€ƒSurfacePolishing.cpp:605-620è¡Œçš„åœ†å‘¨è¿åŠ¨å®ç°
        Vector3d rel_pos = pos - circle_center_;
        double R = rel_pos.head<2>().norm();
        double theta = atan2(rel_pos.y(), rel_pos.x());
        
        Vector3d velocity;
        velocity.x() = -(R - radius_) * cos(theta) - R * omega_ * sin(theta);
        velocity.y() = -(R - radius_) * sin(theta) + R * omega_ * cos(theta);
        velocity.z() = 0;  // åœ†å‘¨è¿åŠ¨åœ¨å¹³é¢å†…
        
        return velocity;
    }
};
```

#### 1.1.2 æ‰°åŠ¨æ¢å¤æœºåˆ¶çš„DSç†è®ºåŸºç¡€ â­

**DSç›¸æ¯”è½¨è¿¹è·Ÿè¸ªçš„æ ¸å¿ƒä¼˜åŠ¿**ï¼š

```python
# ä¼ ç»Ÿè½¨è¿¹è·Ÿè¸ªçš„æ‰°åŠ¨å¤„ç†ï¼ˆå¤æ‚ï¼‰
def trajectory_based_control():
    if disturbance_detected():
        # 1. æ£€æµ‹æ‰°åŠ¨
        # 2. åœæ­¢å½“å‰è½¨è¿¹
        # 3. é‡æ–°è§„åˆ’è½¨è¿¹
        # 4. å¹³æ»‘è¿‡æ¸¡åˆ°æ–°è½¨è¿¹
        # 5. ç»§ç»­æ‰§è¡Œ
        pass  # éœ€è¦å¤æ‚çš„çŠ¶æ€æœºå’Œé‡è§„åˆ’é€»è¾‘

# DSæ–¹æ³•çš„æ‰°åŠ¨å¤„ç†ï¼ˆè‡ªç„¶ï¼‰
def ds_based_control():
    # DSå¤©ç„¶å…·æœ‰æ‰°åŠ¨æ¢å¤èƒ½åŠ›ï¼
    current_velocity = ds_function(current_position, target)
    # æ— è®ºå½“å‰ä½ç½®å¦‚ä½•å˜åŒ–ï¼ŒDSéƒ½ä¼šé‡æ–°è®¡ç®—æœ€ä¼˜é€Ÿåº¦
    # è‡ªåŠ¨æ”¶æ•›å›ç›®æ ‡ï¼Œæ— éœ€é‡è§„åˆ’ï¼
```

**å…·ä½“å®ç°**ï¼š
  ```cpp
class DisturbanceRecoveryManager {
public:
    Vector3d applyRecovery(const Vector3d& nominal_ds, 
                          const ExternalForce& disturbance) {
        
        if (disturbance.magnitude() > DISTURBANCE_THRESHOLD) {
            // DSç†è®ºä¼˜åŠ¿ï¼šæ— éœ€å¤æ‚å¤„ç†ï¼Œåªéœ€è®°å½•æ¢å¤å¼€å§‹
            recovery_start_time_ = ros::Time::now();
            ROS_INFO("æ‰°åŠ¨æ£€æµ‹ï¼š%.3f Nï¼ŒDSè‡ªåŠ¨æ¢å¤ä¸­...", disturbance.magnitude());
        }
        
        // DSè‡ªåŠ¨ä»æ–°ä½ç½®é‡æ–°è®¡ç®—æ”¶æ•›é€Ÿåº¦
        // è¿™å°±æ˜¯DSçš„"å…¨å±€ç¨³å®šæ€§"ä¼˜åŠ¿
        return nominal_ds;  // DSæœ¬èº«å°±å…·æœ‰æ‰°åŠ¨æ¢å¤èƒ½åŠ›ï¼
    }
    
private:
    ros::Time recovery_start_time_;
    double DISTURBANCE_THRESHOLD = 2.0;  // 2Næ‰°åŠ¨æ£€æµ‹é˜ˆå€¼
  };
  ```

#### 1.1.3 èƒ½é‡ç½æ— æºæ€§è®¾è®¡ â­

**è§£å†³å½“å‰ç³»ç»Ÿç¼ºå¤±çš„æ— æºæ€§ä¿è¯**ï¼š

```cpp
class EnergyTankManager {
private:
    double s_;              // å½“å‰èƒ½é‡æ°´å¹³ [J]
    double s_max_;          // æœ€å¤§èƒ½é‡å®¹é‡ [J] 
    
    // åŠŸç‡é¡¹ï¼ˆå‚è€ƒSurfacePolishing.cpp:595-623ï¼‰
    double p_d_;            // è€—æ•£åŠŸç‡ï¼šv^T D v
    double p_n_;            // æ ‡ç§°DSåŠŸç‡ï¼šd1 * v^T * f(x)  
    double p_f_;            // åŠ›åé¦ˆåŠŸç‡ï¼šF_d * v^T * e1
    
    // æ ‡é‡è°ƒèŠ‚å‡½æ•°
    double alpha_, beta_, gamma_, gamma_p_;
    
public:
    Vector3d constrainVelocity(const Vector3d& desired_velocity,
                              const Vector3d& current_velocity,
                              const ForceReading& contact_force) {
        
        // 1. è®¡ç®—å„é¡¹åŠŸç‡ï¼ˆå‚è€ƒè®ºæ–‡Eq.15-17ï¼‰
        updatePowerTerms(desired_velocity, current_velocity, contact_force);
        
        // 2. èƒ½é‡ç½åŠ¨åŠ›å­¦ï¼ˆå‚è€ƒè®ºæ–‡Eq.14ï¼‰
        // á¹¡ = Î±*p_d - Î²*p_n - Î³*p_f
        double ds_dt = alpha_ * p_d_ - beta_ * p_n_ - gamma_ * p_f_;
        
        // 3. æ›´æ–°èƒ½é‡æ°´å¹³
        s_ = std::clamp(s_ + ds_dt * dt_, 0.0, s_max_);
        
        // 4. æ— æºæ€§çº¦æŸæ£€æŸ¥
        if (isViolatingPassivity(ds_dt)) {
            // è¿åæ— æºæ€§ï¼šé™åˆ¶é€Ÿåº¦
            return applyPassivityConstraint(desired_velocity);
        }
        
        return desired_velocity;  // å®‰å…¨ï¼Œå…è®¸æ‰§è¡Œ
    }
    
private:
    void updatePowerTerms(const Vector3d& vd, const Vector3d& v, 
                         const ForceReading& force) {
        // å‚è€ƒSurfacePolishing.cpp:595-623è¡Œçš„å…·ä½“å®ç°
        p_d_ = v.transpose() * damping_matrix_ * v;           // è€—æ•£åŠŸç‡
        p_n_ = d1_ * v.dot(nominal_ds_);                      // æ ‡ç§°DSåŠŸç‡
        p_f_ = desired_force_ * v.dot(surface_normal_);       // åŠ›åé¦ˆåŠŸç‡
        
        // æ›´æ–°æ ‡é‡å‡½æ•°ï¼ˆå‚è€ƒè®ºæ–‡åŠ¨æ€è°ƒèŠ‚ç­–ç•¥ï¼‰
        updateScalarFunctions();
    }
    
    bool isViolatingPassivity(double power_flow) {
        // æ£€æŸ¥æ˜¯å¦è¿åæ— æºæ€§çº¦æŸ
        return (s_ <= 0.0) && (power_flow < 0.0);
    }
    
    Vector3d applyPassivityConstraint(const Vector3d& desired_vel) {
        // èƒ½é‡ä¸è¶³æ—¶çš„å®‰å…¨ç­–ç•¥
        if (s_ <= 0.0) {
            // åªå…è®¸è€—æ•£æ€§è¿åŠ¨
            return computeDissipativeVelocity();
        }
        
        // æŒ‰èƒ½é‡æ¯”ä¾‹ç¼©æ”¾
        double energy_ratio = s_ / s_max_;
        return energy_ratio * desired_vel;
    }
  };
  ```

### 1.2 æ•°æ®æµè®¾è®¡ â­

#### 1.2.1 å®Œæ•´çš„æ§åˆ¶æ•°æ®æµ
```
ä¼ æ„Ÿå™¨è¾“å…¥ â†’ çŠ¶æ€ä¼°è®¡ â†’ DSè®¡ç®— â†’ èƒ½é‡çº¦æŸ â†’ é€Ÿåº¦å‘½ä»¤ â†’ Frankaæ‰§è¡Œ
     â†“           â†“         â†“         â†“         â†“         â†“
  åŠ›ä¼ æ„Ÿå™¨    æœºå™¨äººçŠ¶æ€   å‘é‡åœº     èƒ½é‡ç½    å®‰å…¨é€Ÿåº¦   å®é™…è¿åŠ¨
  ä½ç½®ç¼–ç å™¨   æ¥è§¦æ£€æµ‹    è®¡ç®—      æ— æºæ€§     é™åˆ¶      åé¦ˆ
  å¤–éƒ¨æ‰°åŠ¨    è¡¨é¢ä¼°è®¡    æ‰°åŠ¨æ¢å¤   åŠŸç‡ç›‘æ§   æŒ‡ä»¤å‘é€   çŠ¶æ€æ›´æ–°
```

**è¯¦ç»†æ•°æ®æµ**ï¼š
```cpp
// ä¸»æ§åˆ¶å¾ªç¯æ•°æ®æµ
void UnifiedDSController::update(const ros::Time& time, const ros::Duration& period) {
    
    // 1. ä¼ æ„Ÿå™¨æ•°æ®è·å–ä¸èåˆ
    RobotState state = sensor_manager_->updateAllSensors();
    /*
    state.position        // æ¥è‡ªFrankaç¼–ç å™¨
    state.velocity        // æ¥è‡ªFrankaé€Ÿåº¦ä¼°è®¡  
    state.contact_force   // æ¥è‡ªåŠ›ä¼ æ„Ÿå™¨
    state.external_force  // æ¥è‡ªæ‰°åŠ¨æ£€æµ‹
    */
    
    // 2. æ¥è§¦çŠ¶æ€ä¼°è®¡
    ContactState contact = contact_detector_->classify(state);
    /*
    contact.is_in_contact     // æ˜¯å¦æ¥è§¦
    contact.surface_normal    // è¡¨é¢æ³•å‘é‡
    contact.contact_position  // æ¥è§¦ç‚¹ä½ç½®
    */
    
    // 3. ç»Ÿä¸€DSå‘é‡åœºè®¡ç®—
    Vector3d ds_velocity = computeUnifiedDS(state, contact);
    /*
    if (FREE_SPACE):     ds_velocity = linear_ds_->compute(...)
    if (APPROACHING):    ds_velocity = approach_ds_->compute(...)  
    if (IN_CONTACT):     ds_velocity = contact_ds_->compute(...)
    */
    
    // 4. æ‰°åŠ¨æ¢å¤å¤„ç†
    ds_velocity = disturbance_manager_->applyRecovery(ds_velocity, state.external_force);
    
    // 5. èƒ½é‡ç½æ— æºæ€§çº¦æŸ
    Vector3d safe_velocity = energy_tank_->constrainVelocity(ds_velocity, state);
    
    // 6. å®‰å…¨é™åˆ¶ä¸æŒ‡ä»¤å‘é€
    safe_velocity = DSUtils::clampVelocity(safe_velocity, MAX_VELOCITY);
    velocity_handle_->setCommand(eigenToArray(safe_velocity));
    
    // 7. çŠ¶æ€æœºæ›´æ–°ï¼ˆç®€åŒ–çš„4çŠ¶æ€ï¼‰
    updateControlPhase(state, contact);
}
```

#### 1.2.2 è¡¨é¢æ¥è§¦çš„æ¸è¿›å¤„ç†ç­–ç•¥
  ```cpp
class SurfaceApproachManager {
public:
    ApproachStrategy planApproach(const Vector3d& current_pos, 
                                 const Vector3d& target_surface_point) {
        
        ApproachStrategy strategy;
        
        // é˜¶æ®µ1ï¼šè‡ªç”±ç©ºé—´çº¿æ€§æ¥è¿‘
        strategy.phase1_target = target_surface_point + Vector3d(0, 0, SAFE_HEIGHT);
        strategy.phase1_ds = LinearDS(lambda_approach_, max_vel_approach_);
        
        // é˜¶æ®µ2ï¼šå—æ§ä¸‹æ¢
        strategy.phase2_descent_velocity = Vector3d(0, 0, -DESCENT_SPEED);  // -1mm/s
        strategy.phase2_force_threshold = CONTACT_THRESHOLD;  // 0.3N
        
        // é˜¶æ®µ3ï¼šæ¥è§¦åç¨³å®š
        strategy.phase3_stabilization_time = 2.0;  // 2ç§’ç¨³å®š
        
        return strategy;
    }
    
    Vector3d computeApproachDS(const Vector3d& pos, const ApproachStrategy& strategy) {
        double height_above_surface = pos.z() - target_surface_point_.z();
        
        if (height_above_surface > SAFE_HEIGHT) {
            // è‡ªç”±ç©ºé—´ï¼šçº¿æ€§æ¥è¿‘åˆ°å®‰å…¨é«˜åº¦
            return strategy.phase1_ds.computeVelocity(pos, strategy.phase1_target);
        } else {
            // æ¥è¿‘è¡¨é¢ï¼šæ··åˆè¿åŠ¨ï¼ˆæ°´å¹³æ”¶æ•› + å‚ç›´ä¸‹æ¢ï¼‰
            Vector3d horizontal_ds = computeHorizontalAlignment(pos);
            Vector3d vertical_ds = strategy.phase2_descent_velocity;
            
            // è·ç¦»è¡¨é¢è¶Šè¿‘ï¼Œä¸‹æ¢åˆ†é‡è¶Šå¤§
            double descent_weight = computeDescentWeight(height_above_surface);
            return (1.0 - descent_weight) * horizontal_ds + descent_weight * vertical_ds;
        }
    }
  };
  ```

### 1.3 æ•°å­¦ç†è®ºé‡æ–°ç¡®è®¤

#### 1.3.1 DSé€Ÿåº¦åœºçš„çº¯é€Ÿåº¦æœ¬è´¨
**å‚è€ƒforce_based_ds_modulation/src/SurfacePolishing.cpp:565-641è¡Œ**

```cpp
// DSç³»ç»Ÿçš„å®Œæ•´æ•°æ®æµ(æ— ä½ç½®è®¡ç®—):
void SurfacePolishing::computeModulatedDS() {
  // 1. è®¡ç®—è°ƒåˆ¶ç³»æ•°Î»
  float delta = std::pow(2.0f*_e1.dot(_fx)*_gammap*_Fd/_d1,2.0f) + 4.0f*std::pow(_fx.norm(),4.0f);
  float la = (-2.0f*_e1.dot(_fx)*_gammap*_Fd/_d1 + sqrt(delta)) / (2.0f*std::pow(_fx.norm(),2.0f));
  
  // 2. è®¡ç®—è°ƒåˆ¶åçš„æœŸæœ›é€Ÿåº¦
  _vd = la*_fx + _gammap*_Fd*_e1/_d1;
  
  // 3. é€Ÿåº¦å®‰å…¨é™åˆ¶
  if(_vd.norm() > _velocityLimit) {
    _vd *= _velocityLimit/_vd.norm();
  }
  
  // 4. ç›´æ¥å‘å¸ƒé€Ÿåº¦å‘½ä»¤(æ— ç§¯åˆ†!)
  _msgDesiredTwist.linear.x = _vd(0);
  _msgDesiredTwist.linear.y = _vd(1);
  _msgDesiredTwist.linear.z = _vd(2);
  _pubDesiredTwist.publish(_msgDesiredTwist);
}
```

#### 1.3.2 æ ‡å‡†DSæ•°å­¦æ¨¡å‹ç¡®è®¤
```
çº¿æ€§DS (æ¥è¿‘è¿åŠ¨):
  f(x) = -Î»(x - x*)
  è¾“å‡º: é€Ÿåº¦å‘é‡ v âˆˆ â„Â³

åœ†å‘¨DS (æŠ›å…‰è¿åŠ¨):  
  f(x) = getCircularMotionVelocity(x, center, radius)
  è¾“å‡º: åˆ‡å‘é€Ÿåº¦å‘é‡ v âˆˆ â„Â³

ç»„åˆDS (è¿‡æ¸¡è¿åŠ¨):
  f(x) = R * v_target  // Rä¸ºæ—‹è½¬è¿‡æ¸¡çŸ©é˜µ
  è¾“å‡º: æ··åˆé€Ÿåº¦å‘é‡ v âˆˆ â„Â³

è°ƒåˆ¶DS (åŠ›åé¦ˆ):
  v_d = Î»*f(x) + (Î³_p*F_d/d1)*e1
  è¾“å‡º: æœ€ç»ˆæœŸæœ›é€Ÿåº¦ v_d âˆˆ â„Â³
```

#### 1.3.3 Franka vs KUKAæ§åˆ¶æ¥å£å¯¹æ¯”
```
DSåŸå§‹ç³»ç»Ÿ(KUKA LWR):
  è¯é¢˜: /lwr/joint_controllers/passive_ds_command_vel
  ç±»å‹: geometry_msgs::Twist
  æ¥å£: passive_ds_command_velé€Ÿåº¦æ§åˆ¶å™¨
  
Frankaå¯¹åº”æ¥å£:
  æ¥å£: franka_hw::FrankaVelocityCartesianInterface  
  å¥æŸ„: franka_hw::FrankaCartesianVelocityHandle
  å‘½ä»¤: std::array<double, 6> velocity_command
```

### 1.4 å…³é”®æŠ€æœ¯é—®é¢˜è§£å†³æ–¹æ¡ˆ â­

#### 1.4.1 æœªçŸ¥è¡¨é¢ä½ç½®çš„DSå¤„ç†ç­–ç•¥

**é—®é¢˜**: è¡¨é¢ä½ç½®æœªçŸ¥ï¼Œéœ€è¦"ç§»åŠ¨åˆ°ä¸Šæ–¹â†’ä¸‹æ¢â†’æ¥è§¦æ£€æµ‹"

**DSè§£å†³æ–¹æ¡ˆ**ï¼š
```cpp
class AdaptiveSurfaceDS {
private:
    Vector3d estimated_surface_point_;  // ä¼°è®¡çš„è¡¨é¢ä½ç½®
    bool surface_found_;               // æ˜¯å¦å·²æ‰¾åˆ°è¡¨é¢
    
public:
    Vector3d computeAdaptiveDS(const Vector3d& current_pos, 
                              const ForceReading& force) {
        
        if (!surface_found_) {
            // é˜¶æ®µ1ï¼šæ¢ç´¢æ€§ä¸‹æ¢DS
            return computeExploratoryDS(current_pos, force);
        } else {
            // é˜¶æ®µ2ï¼šå·²çŸ¥è¡¨é¢çš„æ¥è§¦DS
            return computeContactDS(current_pos, force);
        }
    }
    
private:
    Vector3d computeExploratoryDS(const Vector3d& pos, const ForceReading& force) {
        // ç»„åˆDSï¼šæ°´å¹³æ”¶æ•›åˆ°ç›®æ ‡xy + ç¼“æ…¢ä¸‹æ¢z
        Vector3d horizontal_ds = computeHorizontalConvergence(pos);
        Vector3d vertical_ds = Vector3d(0, 0, -EXPLORATION_SPEED);  // -0.5mm/sæ…¢é€Ÿä¸‹æ¢
        
        // æ¥è§¦æ£€æµ‹
        if (force.z() > CONTACT_THRESHOLD) {
            // å‘ç°è¡¨é¢ï¼è®°å½•ä½ç½®å¹¶åˆ‡æ¢æ¨¡å¼
            estimated_surface_point_ = pos;
            surface_found_ = true;
            ROS_INFO("è¡¨é¢å‘ç°äºä½ç½®: [%.3f, %.3f, %.3f]", pos.x(), pos.y(), pos.z());
        }
        
        // æƒé‡ç»„åˆï¼šè¶Šæ¥è¿‘ç›®æ ‡æ°´å¹³ä½ç½®ï¼Œä¸‹æ¢åˆ†é‡è¶Šå¤§
        double exploration_weight = computeExplorationWeight(pos);
        return (1.0 - exploration_weight) * horizontal_ds + exploration_weight * vertical_ds;
    }
    
    Vector3d computeHorizontalConvergence(const Vector3d& pos) {
        // åªåœ¨xyå¹³é¢æ”¶æ•›åˆ°ç›®æ ‡ï¼Œzæ–¹å‘ä¿æŒå½“å‰
        Vector3d target_xy = target_position_;
        target_xy.z() = pos.z();  // ä¿æŒå½“å‰é«˜åº¦
        
        Vector3d error = target_xy - pos;
        return -lambda_horizontal_ * error;
    }
    
    double computeExplorationWeight(const Vector3d& pos) {
        // è·ç¦»ç›®æ ‡xyä½ç½®è¶Šè¿‘ï¼Œä¸‹æ¢æƒé‡è¶Šå¤§
        Vector2d xy_error = target_position_.head<2>() - pos.head<2>();
        double xy_distance = xy_error.norm();
        
        return exp(-xy_distance / EXPLORATION_TRANSITION_SCALE);
    }
};
```

#### 1.4.2 è‡ªç”±ç©ºé—´åˆ°æ¥è§¦ç©ºé—´çš„å¹³æ»‘è¡”æ¥

**å…³é”®è®¾è®¡**ï¼šä½¿ç”¨**æƒé‡æ··åˆ**å®ç°å¹³æ»‘è¿‡æ¸¡

```cpp
class SpaceTransitionManager {
public:
    Vector3d computeTransitionDS(const Vector3d& pos, 
                               const ContactState& contact,
                               const ForceReading& force) {
        
        // è®¡ç®—å„ç©ºé—´çš„DS
        Vector3d free_space_ds = computeFreeSpaceDS(pos);
        Vector3d contact_ds = computeContactDS(pos, force);
        
        // æ ¹æ®æ¥è§¦çŠ¶æ€è®¡ç®—æ··åˆæƒé‡
        double contact_weight = computeContactWeight(contact, force);
        
        // å¹³æ»‘æ··åˆ
        Vector3d blended_ds = (1.0 - contact_weight) * free_space_ds + 
                             contact_weight * contact_ds;
        
        return blended_ds;
    }
    
private:
    double computeContactWeight(const ContactState& contact, 
                              const ForceReading& force) {
        
        if (contact.state == FREE_SPACE) {
            return 0.0;  // çº¯è‡ªç”±ç©ºé—´DS
        } else if (contact.state == FIRM_CONTACT) {
            return 1.0;  // çº¯æ¥è§¦DS
        } else {
            // è¿‡æ¸¡é˜¶æ®µï¼šåŸºäºåŠ›å¤§å°çš„è½¯åˆ‡æ¢
            double force_ratio = force.magnitude() / MAX_CONTACT_FORCE;
            return std::clamp(force_ratio, 0.0, 1.0);
        }
    }
};
```

#### 1.4.3 æ‰°åŠ¨æ¢å¤çš„å…·ä½“å®ç°æœºåˆ¶

**DSå¤©ç„¶ä¼˜åŠ¿çš„æŠ€æœ¯å®ç°**ï¼š

```cpp
class RobustDSManager {
public:
    Vector3d computeRobustDS(const Vector3d& current_pos,
                           const Vector3d& current_vel,
                           const ExternalForce& disturbance) {
        
        // 1. æ ‡å‡†DSè®¡ç®—ï¼ˆåŸºäºå½“å‰ä½ç½®ï¼‰
        Vector3d nominal_ds = ds_primitive_->computeVelocity(current_pos, target_);
        
        // 2. æ‰°åŠ¨æ£€æµ‹ä¸åˆ†ç±»
        DisturbanceType disturbance_type = classifyDisturbance(disturbance);
        
        // 3. æ ¹æ®æ‰°åŠ¨ç±»å‹åº”ç”¨ä¸åŒç­–ç•¥
        Vector3d robust_ds = applyRobustnessStrategy(nominal_ds, disturbance_type);
        
        return robust_ds;
    }
    
private:
    DisturbanceType classifyDisturbance(const ExternalForce& force) {
        double magnitude = force.magnitude();
        
        if (magnitude < SMALL_DISTURBANCE_THRESHOLD) {
            return NO_DISTURBANCE;
        } else if (magnitude < MEDIUM_DISTURBANCE_THRESHOLD) {
            return SMALL_DISTURBANCE;  // <1Nï¼šå¿½ç•¥ï¼ŒDSè‡ªç„¶å¤„ç†
        } else if (magnitude < LARGE_DISTURBANCE_THRESHOLD) {
            return MEDIUM_DISTURBANCE; // 1-5Nï¼šå‡é€Ÿä½†ç»§ç»­
        } else {
            return LARGE_DISTURBANCE;  // >5Nï¼šç´§æ€¥åœæ­¢
        }
    }
    
    Vector3d applyRobustnessStrategy(const Vector3d& nominal_ds, 
                                   DisturbanceType type) {
        switch (type) {
            case NO_DISTURBANCE:
            case SMALL_DISTURBANCE:
                // DSè‡ªç„¶å¤„ç†ï¼Œæ— éœ€ä¿®æ”¹
                return nominal_ds;
                
            case MEDIUM_DISTURBANCE:
                // ä¿æŒæ–¹å‘ï¼Œé™ä½é€Ÿåº¦
                return 0.5 * nominal_ds;
                
            case LARGE_DISTURBANCE:
                // ç´§æ€¥åˆ¶åŠ¨ï¼Œä½†ä¿æŒæœå‘ç›®æ ‡çš„å°é€Ÿåº¦
                return 0.1 * nominal_ds.normalized() * MIN_RECOVERY_SPEED;
                
            default:
                return Vector3d::Zero();
        }
    }
};
```

### 1.5 ç³»ç»Ÿæ¶æ„é‡æ–°è®¾è®¡ (åŸºäºDSå¼€æºä»£ç æ¨¡å¼)

#### 1.3.1 ç»Ÿä¸€çš„åŸºç¡€ç»„ä»¶æ¶æ„ (æ¶ˆé™¤é‡å¤ä»£ç )

**å…³é”®å‘ç°**ï¼šDSå¼€æºä»£ç è™½ç„¶æœ‰Utilså·¥å…·ç±»ï¼Œä½†ä»å­˜åœ¨å¤§é‡é‡å¤ä»£ç ã€‚æˆ‘ä»¬è®¾è®¡ç»Ÿä¸€æ¶æ„é¿å…è¿™ä¸ªé—®é¢˜ã€‚

```cpp
namespace franka_ds {

// ========== åŸºç¡€çŠ¶æ€ç®¡ç†å™¨ (ç»Ÿä¸€æ‰€æœ‰çŠ¶æ€å˜é‡) ==========
class DSRobotState {
private:
  // æœºå™¨äººçŠ¶æ€ (ç»Ÿä¸€ç®¡ç†)
  Eigen::Vector3d position_;           // å½“å‰ä½ç½® _x
  Eigen::Vector3d velocity_;           // å½“å‰é€Ÿåº¦ _v
  Eigen::Vector4d quaternion_;         // å½“å‰å››å…ƒæ•° _q
  Eigen::Matrix3d rotation_matrix_;    // æ—‹è½¬çŸ©é˜µ _wRb
  
  // åŠ›ä¼ æ„Ÿå™¨çŠ¶æ€ (ç»Ÿä¸€ç®¡ç†)  
  Eigen::Matrix<double,6,1> wrench_;          // å½“å‰åŠ›/åŠ›çŸ©
  Eigen::Matrix<double,6,1> wrench_bias_;     // åŠ›ä¼ æ„Ÿå™¨åç½®
  Eigen::Matrix<double,6,1> filtered_wrench_; // æ»¤æ³¢ååŠ›/åŠ›çŸ©
  double normal_force_;                       // æ³•å‘åŠ›
  double normal_distance_;                    // æ³•å‘è·ç¦»
  
  // ROSæ¥å£çŠ¶æ€
  bool first_pose_received_;
  bool first_twist_received_;
  bool wrench_bias_ok_;
  int wrench_count_;
  
public:
  // ç»Ÿä¸€çš„çŠ¶æ€æ›´æ–°æ¥å£
  void updateRobotPose(const franka::RobotState& robot_state);
  void updateRobotWrench(const geometry_msgs::WrenchStamped::ConstPtr& msg);
  
  // ç»Ÿä¸€çš„çŠ¶æ€è®¿é—®æ¥å£
  const Eigen::Vector3d& getPosition() const { return position_; }
  const Eigen::Vector3d& getVelocity() const { return velocity_; }
  double getNormalForce() const { return normal_force_; }
  bool isInitialized() const { return first_pose_received_ && wrench_bias_ok_; }
};

// ========== èƒ½é‡ç½ç®¡ç†å™¨ (ç»Ÿä¸€æ— æºæ€§è®¡ç®—) ==========
class EnergyTankManager {
private:
  double s_;              // å½“å‰èƒ½é‡æ°´å¹³
  double s_max_;          // æœ€å¤§èƒ½é‡æ°´å¹³
  double alpha_, beta_, gamma_, gamma_p_;  // æ ‡é‡å‡½æ•°
  double p_n_, p_f_, p_d_;  // åŠŸç‡é¡¹
  double d_w_;            // åŠŸç‡æµ
  double d1_;             // DS-é˜»æŠ—å¢ç›Š
  
public:
  // ç»Ÿä¸€çš„èƒ½é‡ç½æ›´æ–° (æ¶ˆé™¤é‡å¤ä»£ç )
  void updateTankDynamics(
      const Eigen::Vector3d& velocity,
      const Eigen::Vector3d& nominal_ds,
      const Eigen::Matrix3d& damping_matrix,
      double desired_force,
      const Eigen::Vector3d& normal_vector,
      double dt);
      
  // ç»Ÿä¸€çš„æ ‡é‡å‡½æ•°è®¡ç®— (å‚è€ƒSurfacePolishing.cpp:561-592)
  void updateTankScalars();
  
  double getEnergyScaleFactor() const;
  bool isMotionAllowed(double required_power) const;
};

// ========== DSåŸè¯­åŸºç±» (ç»Ÿä¸€DSè®¡ç®—æ¥å£) ==========
class DSPrimitive {
public:
  virtual ~DSPrimitive() = default;
  virtual Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position) = 0;
  virtual bool isConverged(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position,
      double tolerance = 0.01) const = 0;
  virtual std::string getName() const = 0;
};

// ========== å…·ä½“DSåŸè¯­å®ç° ==========
class LinearDS : public DSPrimitive {
private:
  Eigen::Matrix3d lambda_;  // æ”¶æ•›ç‡çŸ©é˜µ
  double max_velocity_;     // é€Ÿåº¦é™åˆ¶
  
public:
  LinearDS(const Eigen::Matrix3d& lambda, double max_vel)
      : lambda_(lambda), max_velocity_(max_vel) {}
      
  Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position) override {
    Eigen::Vector3d error = target_position - current_position;
    Eigen::Vector3d velocity = -lambda_ * error;
    
    // é€Ÿåº¦é™åˆ¶ (å‚è€ƒSurfacePolishing.cpp:641è¡Œ)
    if (velocity.norm() > max_velocity_) {
      velocity *= max_velocity_ / velocity.norm();
    }
    return velocity;
  }
  
  bool isConverged(const Eigen::Vector3d& current_pos,
                  const Eigen::Vector3d& target_pos,
                  double tolerance) const override {
    return (target_pos - current_pos).norm() < tolerance;
  }
  
  std::string getName() const override { return "LinearDS"; }
};

class CircularDS : public DSPrimitive {
private:
  double radius_;           // åœ†å‘¨åŠå¾„
  double angular_velocity_; // è§’é€Ÿåº¦
  
public:
  CircularDS(double radius, double omega) 
      : radius_(radius), angular_velocity_(omega) {}
      
  Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& center) override {
    // å‚è€ƒSurfacePolishing.cpp:605-620è¡Œçš„getCircularMotionVelocityå®ç°
    Eigen::Vector3d position_rel = current_position - center;
    double R = sqrt(position_rel.x() * position_rel.x() + 
                   position_rel.y() * position_rel.y());
    double theta = atan2(position_rel.y(), position_rel.x());
    
    Eigen::Vector3d velocity;
    velocity.x() = -(R - radius_) * cos(theta) - R * angular_velocity_ * sin(theta);
    velocity.y() = -(R - radius_) * sin(theta) + R * angular_velocity_ * cos(theta);
    velocity.z() = -position_rel.z();  // å‚ç›´æ–¹å‘å›åˆ°å¹³é¢
    
    return velocity;
  }
  
  bool isConverged(const Eigen::Vector3d& current_pos,
                  const Eigen::Vector3d& center,
                  double tolerance) const override {
    Eigen::Vector3d pos_rel = current_pos - center;
    double current_radius = sqrt(pos_rel.x() * pos_rel.x() + pos_rel.y() * pos_rel.y());
    return abs(current_radius - radius_) < tolerance && abs(pos_rel.z()) < tolerance;
  }
  
  std::string getName() const override { return "CircularDS"; }
};

// ========== å·¥å…·ç±» (å‚è€ƒDSå¼€æºçš„Utils.hæ¨¡å¼) ==========
class DSUtils {
public:
  // å¹³æ»‘è¡°å‡å‡½æ•° (å‚è€ƒUtils::smoothFall)
  static double smoothFall(double x, double a, double b) {
    if (x < a) return 1.0;
    if (x > b) return 0.0;
    return 0.5 * (1.0 + cos(M_PI * (x - a) / (b - a)));
  }
  
  // é€Ÿåº¦å®‰å…¨é™åˆ¶
  static Eigen::Vector3d clampVelocity(const Eigen::Vector3d& velocity, double max_vel) {
    if (velocity.norm() > max_vel) {
      return velocity * (max_vel / velocity.norm());
    }
    return velocity;
  }
  
  // å››å…ƒæ•°å·¥å…·å‡½æ•° (å‚è€ƒUtilsç±»)
  static Eigen::Matrix3d quaternionToRotationMatrix(const Eigen::Vector4d& q);
  static Eigen::Vector4d rotationMatrixToQuaternion(const Eigen::Matrix3d& R);
  static Eigen::Vector4d slerpQuaternion(const Eigen::Vector4d& q1, 
                                        const Eigen::Vector4d& q2, double t);
};

// ========== ç»Ÿä¸€çš„DSæ§åˆ¶å™¨ (æ¶ˆé™¤å„é˜¶æ®µé‡å¤é€»è¾‘) ==========
class UnifiedDSController : public controller_interface::MultiInterfaceController<
    franka_hw::FrankaVelocityCartesianInterface,
    franka_hw::FrankaStateInterface> {
    
private:
  // ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†
  std::unique_ptr<DSRobotState> robot_state_manager_;
  std::unique_ptr<EnergyTankManager> energy_tank_manager_;
  
  // DSåŸè¯­é›†åˆ (é¿å…åˆ†æ•£çš„å®ç°)
  std::unique_ptr<LinearDS> linear_ds_;
  std::unique_ptr<CircularDS> circular_ds_;
  std::unique_ptr<OrientationDS> orientation_ds_;  // æ–°å¢ï¼šå§¿æ€æ§åˆ¶DS
  
  // Frankaé€Ÿåº¦æ§åˆ¶æ¥å£
  franka_hw::FrankaVelocityCartesianInterface* velocity_interface_;
  std::unique_ptr<franka_hw::FrankaCartesianVelocityHandle> velocity_handle_;
  
  // ROSæ¥å£é›†æˆï¼ˆä¸ç°æœ‰èŠ‚ç‚¹å…¼å®¹ï¼‰
  ros::Subscriber force_sensor_sub_;    // è®¢é˜…force_sensor_readeræ•°æ®
  ros::Subscriber user_command_sub_;    // è®¢é˜…ç”¨æˆ·startæŒ‡ä»¤
  
  // æ§åˆ¶çŠ¶æ€
  enum ControlPhase {
    CALIBRATION,       // æ ¡å‡†é˜¶æ®µ (é€Ÿåº¦=0)
    LINEAR_APPROACH,   // çº¿æ€§æ¥è¿‘ (LinearDS)
    PROBE_DESCENT,     // æ¢å¤´ä¸‹æ¢ (ä¿®æ­£LinearDS)
    CIRCULAR_MOTION    // åœ†å‘¨è¿åŠ¨ (CircularDS)
  };
  ControlPhase current_phase_;
  
  // å‚æ•°åŒ–é…ç½®ï¼ˆä»ROSå‚æ•°æœåŠ¡å™¨åŠ è½½ï¼Œé¿å…ç¡¬ç¼–ç ï¼‰
  struct DSParameters {
    // çº¿æ€§DSå‚æ•°
    double linear_lambda_;           // æ”¶æ•›ç‡ (é»˜è®¤: 2.0)
    double linear_max_velocity_;     // æœ€å¤§é€Ÿåº¦ (é»˜è®¤: 0.05 m/s)
    
    // åœ†å‘¨DSå‚æ•°  
    double circular_radius_;         // åœ†å‘¨åŠå¾„ (å¯é…ç½®: 0.025æˆ–0.075)
    double circular_omega_;          // è§’é€Ÿåº¦ (é»˜è®¤: Ï€ rad/s)
    
    // æ¥è§¦æ£€æµ‹å‚æ•°
    double contact_force_threshold_; // æ¥è§¦åŠ›é˜ˆå€¼ (é»˜è®¤: 0.3N)
    double exploration_speed_;       // ä¸‹æ¢é€Ÿåº¦ (é»˜è®¤: 0.001 m/s)
    
    // èƒ½é‡ç½å‚æ•°
    double energy_tank_max_;         // æœ€å¤§èƒ½é‡ (é»˜è®¤: 4.0J)
    double energy_dissipation_rate_; // è€—æ•£ç‡
    
    // å§¿æ€æ§åˆ¶å‚æ•°
    bool enable_orientation_control_; // æ˜¯å¦å¯ç”¨å§¿æ€æ§åˆ¶
    double orientation_stiffness_;    // å§¿æ€åˆšåº¦
  } ds_params_;
  
  // ç›®æ ‡å‚æ•° (å„é˜¶æ®µå…±ç”¨)
  Eigen::Vector3d target_position_;
  Eigen::Vector3d circle_center_;
  Eigen::Vector4d desired_orientation_;  // æœŸæœ›å§¿æ€å››å…ƒæ•°
  
public:
  bool init(hardware_interface::RobotHW* robot_hw, ros::NodeHandle& node_handle) override {
    // 1. åˆå§‹åŒ–Frankaé€Ÿåº¦æ§åˆ¶æ¥å£
    velocity_interface_ = robot_hw->get<franka_hw::FrankaVelocityCartesianInterface>();
    if (velocity_interface_ == nullptr) {
      ROS_ERROR("æ— æ³•è·å–Frankaé€Ÿåº¦æ§åˆ¶æ¥å£");
      return false;
    }
    
    std::string arm_id;
    if (!node_handle.getParam("arm_id", arm_id)) {
      ROS_ERROR("æ— æ³•è·å–arm_idå‚æ•°");
      return false;
    }
    
    try {
      velocity_handle_ = std::make_unique<franka_hw::FrankaCartesianVelocityHandle>(
          velocity_interface_->getHandle(arm_id + "_robot"));
    } catch (const std::exception& e) {
      ROS_ERROR_STREAM("é€Ÿåº¦æ§åˆ¶å¥æŸ„åˆå§‹åŒ–å¤±è´¥: " << e.what());
      return false;
    }
    
    // 2. åŠ è½½å‚æ•°åŒ–é…ç½®ï¼ˆè§£å†³ç¡¬ç¼–ç é—®é¢˜ï¼‰
    loadDSParameters(node_handle);
    
    // 3. åˆå§‹åŒ–ç»Ÿä¸€ç»„ä»¶
    robot_state_manager_ = std::make_unique<DSRobotState>();
    energy_tank_manager_ = std::make_unique<EnergyTankManager>(ds_params_.energy_tank_max_);
    
    // 4. åˆå§‹åŒ–DSåŸè¯­ï¼ˆä½¿ç”¨å‚æ•°åŒ–é…ç½®ï¼‰
    Eigen::Matrix3d lambda = Eigen::Matrix3d::Identity() * ds_params_.linear_lambda_;
    linear_ds_ = std::make_unique<LinearDS>(lambda, ds_params_.linear_max_velocity_);
    circular_ds_ = std::make_unique<CircularDS>(ds_params_.circular_radius_, ds_params_.circular_omega_);
    
    // 5. åˆå§‹åŒ–å§¿æ€æ§åˆ¶DSï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (ds_params_.enable_orientation_control_) {
      orientation_ds_ = std::make_unique<OrientationDS>(ds_params_.orientation_stiffness_);
    }
    
    // 6. åˆå§‹åŒ–ROSæ¥å£ï¼ˆä¸ç°æœ‰èŠ‚ç‚¹é›†æˆï¼‰
    setupROSInterface(node_handle);
    
    current_phase_ = CALIBRATION;
    
    ROS_INFO("UnifiedDSControlleråˆå§‹åŒ–æˆåŠŸ");
    ROS_INFO("å‚æ•°é…ç½®: åœ†å‘¨åŠå¾„=%.3fm, çº¿æ€§é€Ÿåº¦=%.3fm/s, æ¥è§¦é˜ˆå€¼=%.1fN", 
             ds_params_.circular_radius_, ds_params_.linear_max_velocity_, ds_params_.contact_force_threshold_);
    return true;
  }
  
  void update(const ros::Time& time, const ros::Duration& period) override {
    // 1. ç»Ÿä¸€çŠ¶æ€æ›´æ–°
    franka::RobotState robot_state = velocity_handle_->getRobotState();
    robot_state_manager_->updateRobotPose(robot_state);
    
    if (!robot_state_manager_->isInitialized()) {
      // å‘é€é›¶é€Ÿåº¦ï¼Œç­‰å¾…åˆå§‹åŒ–å®Œæˆ
      std::array<double, 6> zero_velocity = {0, 0, 0, 0, 0, 0};
      velocity_handle_->setCommand(zero_velocity);
      return;
    }
    
    // 2. ç»Ÿä¸€çš„DSé€Ÿåº¦è®¡ç®—
    Eigen::Vector3d ds_linear_velocity = computeUnifiedDSVelocity();
    Eigen::Vector3d ds_angular_velocity = Eigen::Vector3d::Zero();
    
    // 3. å§¿æ€æ§åˆ¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (ds_params_.enable_orientation_control_ && orientation_ds_) {
      ds_angular_velocity = orientation_ds_->computeAngularVelocity(
          robot_state_manager_->getCurrentOrientation(),
          desired_orientation_);
    }
    
    // 4. ç»Ÿä¸€çš„èƒ½é‡ç½çº¦æŸ
    energy_tank_manager_->updateTankDynamics(
        robot_state_manager_->getVelocity(),
        ds_linear_velocity,
        Eigen::Matrix3d::Identity() * 10.0,  // é˜»å°¼çŸ©é˜µ
        5.0,  // æœŸæœ›åŠ›
        Eigen::Vector3d(0, 0, 1),  // æ³•å‘é‡
        period.toSec());
        
    double energy_scale = energy_tank_manager_->getEnergyScaleFactor();
    Eigen::Vector3d safe_linear_velocity = energy_scale * ds_linear_velocity;
    Eigen::Vector3d safe_angular_velocity = energy_scale * ds_angular_velocity;
    
    // 5. ç»Ÿä¸€çš„å®‰å…¨é™åˆ¶
    safe_linear_velocity = DSUtils::clampVelocity(safe_linear_velocity, ds_params_.linear_max_velocity_);
    safe_angular_velocity = DSUtils::clampVelocity(safe_angular_velocity, 0.5);  // 0.5 rad/sè§’é€Ÿåº¦é™åˆ¶
    
    // 6. å‘é€å®Œæ•´é€Ÿåº¦å‘½ä»¤åˆ°Frankaï¼ˆåŒ…å«çº¿é€Ÿåº¦+è§’é€Ÿåº¦ï¼‰
    std::array<double, 6> velocity_command = {
        safe_linear_velocity.x(), safe_linear_velocity.y(), safe_linear_velocity.z(),
        safe_angular_velocity.x(), safe_angular_velocity.y(), safe_angular_velocity.z()
    };
    velocity_handle_->setCommand(velocity_command);
    
    // 7. ç»Ÿä¸€çš„çŠ¶æ€æœºæ›´æ–°ï¼ˆDSä¼˜åŠ¿ï¼šæ— éœ€ç­‰å¾…ï¼Œç«‹å³å“åº”ï¼‰
    updateControlPhase();
  }
  
private:
  // å‚æ•°åŒ–é…ç½®åŠ è½½ï¼ˆè§£å†³ç¡¬ç¼–ç é—®é¢˜ï¼‰
  void loadDSParameters(ros::NodeHandle& nh) {
    // çº¿æ€§DSå‚æ•°
    nh.param("ds_params/linear_lambda", ds_params_.linear_lambda_, 2.0);
    nh.param("ds_params/linear_max_velocity", ds_params_.linear_max_velocity_, 0.05);
    
    // åœ†å‘¨DSå‚æ•°ï¼ˆæ”¯æŒæ—§ç³»ç»Ÿçš„ä¸¤ç§åŠå¾„é…ç½®ï¼‰
    nh.param("ds_params/circular_radius", ds_params_.circular_radius_, 0.025);  // é»˜è®¤2.5cm
    nh.param("ds_params/circular_omega", ds_params_.circular_omega_, M_PI);     // é»˜è®¤Ï€ rad/s
    
    // æ¥è§¦æ£€æµ‹å‚æ•°
    nh.param("ds_params/contact_force_threshold", ds_params_.contact_force_threshold_, 0.3);
    nh.param("ds_params/exploration_speed", ds_params_.exploration_speed_, 0.001);
    
    // èƒ½é‡ç½å‚æ•°
    nh.param("ds_params/energy_tank_max", ds_params_.energy_tank_max_, 4.0);
    nh.param("ds_params/energy_dissipation_rate", ds_params_.energy_dissipation_rate_, 1.0);
    
    // å§¿æ€æ§åˆ¶å‚æ•°
    nh.param("ds_params/enable_orientation_control", ds_params_.enable_orientation_control_, true);
    nh.param("ds_params/orientation_stiffness", ds_params_.orientation_stiffness_, 5.0);
    
    // å‚æ•°éªŒè¯
    if (ds_params_.circular_radius_ < 0.01 || ds_params_.circular_radius_ > 0.1) {
      ROS_WARN("åœ†å‘¨åŠå¾„ %.3f è¶…å‡ºåˆç†èŒƒå›´[0.01, 0.1]mï¼Œä½¿ç”¨é»˜è®¤å€¼0.025m", ds_params_.circular_radius_);
      ds_params_.circular_radius_ = 0.025;
    }
  }
  
  // ROSæ¥å£è®¾ç½®ï¼ˆä¸ç°æœ‰èŠ‚ç‚¹é›†æˆï¼‰
  void setupROSInterface(ros::NodeHandle& nh) {
    // è®¢é˜…åŠ›ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆå¤ç”¨ç°æœ‰force_sensor_readerèŠ‚ç‚¹ï¼‰
    force_sensor_sub_ = nh.subscribe("/force_sensor/filtered_wrench", 1, 
                                   &UnifiedDSController::forceCallback, this);
    
    // è®¢é˜…ç”¨æˆ·å‘½ä»¤ï¼ˆå¤ç”¨ç°æœ‰çš„å¯åŠ¨æœºåˆ¶ï¼‰
    user_command_sub_ = nh.subscribe("/unified_ds/user_command", 1,
                                   &UnifiedDSController::userCommandCallback, this);
    
    ROS_INFO("ROSæ¥å£åˆå§‹åŒ–å®Œæˆï¼Œé›†æˆç°æœ‰force_sensor_readerèŠ‚ç‚¹");
  }
  
  // åŠ›ä¼ æ„Ÿå™¨æ•°æ®å›è°ƒï¼ˆä¸ç°æœ‰ç³»ç»Ÿå…¼å®¹ï¼‰
  void forceCallback(const geometry_msgs::WrenchStamped::ConstPtr& msg) {
    robot_state_manager_->updateForceReading(*msg);
  }
  
  // ç”¨æˆ·å‘½ä»¤å›è°ƒï¼ˆæ›¿ä»£åŸæœ‰çš„é”®ç›˜è¾“å…¥ï¼‰
  void userCommandCallback(const std_msgs::String::ConstPtr& msg) {
    if (msg->data == "start" && current_phase_ == CALIBRATION) {
      current_phase_ = LINEAR_APPROACH;
      ROS_INFO("æ¥æ”¶åˆ°startå‘½ä»¤ï¼Œå¼€å§‹DSè¿åŠ¨æ§åˆ¶");
    }
  }
  
  // ç»Ÿä¸€çš„DSé€Ÿåº¦è®¡ç®— (æ¶ˆé™¤å„é˜¶æ®µåˆ†æ•£é€»è¾‘)
  Eigen::Vector3d computeUnifiedDSVelocity() {
    Eigen::Vector3d current_pos = robot_state_manager_->getPosition();
    
    switch (current_phase_) {
      case CALIBRATION:
        return Eigen::Vector3d::Zero();  // é™æ­¢
        
      case LINEAR_APPROACH:
        return linear_ds_->computeVelocity(current_pos, target_position_);
        
      case PROBE_DESCENT: {
        // ç»„åˆDSï¼šå‘ä¸‹æ¢æµ‹ + å‘ç›®æ ‡æ¥è¿‘
        Eigen::Vector3d approach_vel = linear_ds_->computeVelocity(current_pos, target_position_);
        Eigen::Vector3d descent_vel(0, 0, -ds_params_.exploration_speed_);
        return approach_vel + descent_vel;
      }
      
      case CIRCULAR_MOTION:
        // DSä¼˜åŠ¿ï¼šç«‹å³å¯åŠ¨åŠ›åé¦ˆæ§åˆ¶ï¼Œæ— éœ€10ç§’ç­‰å¾…ï¼
        return circular_ds_->computeVelocity(current_pos, circle_center_);
        
      default:
        return Eigen::Vector3d::Zero();
    }
  }
  
  // ç»Ÿä¸€çš„çŠ¶æ€æœºæ›´æ–° (DSä¼˜åŠ¿ï¼šç«‹å³å“åº”ï¼Œæ— ç­‰å¾…æ—¶é—´)
  void updateControlPhase() {
    Eigen::Vector3d current_pos = robot_state_manager_->getPosition();
    
    switch (current_phase_) {
      case CALIBRATION:
        // DSä¼˜åŠ¿ï¼šåˆå§‹åŒ–å®Œæˆå³å¯å¼€å§‹ï¼Œæ— éœ€é¢å¤–ç­‰å¾…
        if (robot_state_manager_->isInitialized()) {
          ROS_INFO("DSç³»ç»Ÿå‡†å¤‡å°±ç»ªï¼Œç­‰å¾…startæŒ‡ä»¤");
        }
        break;
        
      case LINEAR_APPROACH:
        if (linear_ds_->isConverged(current_pos, target_position_, 0.008)) {
          current_phase_ = PROBE_DESCENT;
          ROS_INFO("åˆ°è¾¾ç›®æ ‡ï¼Œå¼€å§‹æ¢ç´¢æ€§ä¸‹æ¢");
        }
        break;
        
      case PROBE_DESCENT:
        if (robot_state_manager_->getNormalForce() > ds_params_.contact_force_threshold_) {
          circle_center_ = current_pos;  // ä»¥æ¥è§¦ç‚¹ä¸ºåœ†å¿ƒ
          current_phase_ = CIRCULAR_MOTION;
          ROS_INFO("æ£€æµ‹åˆ°æ¥è§¦ï¼Œç«‹å³å¯åŠ¨åœ†å‘¨è¿åŠ¨å’ŒåŠ›åé¦ˆæ§åˆ¶");
          // DSä¼˜åŠ¿ï¼šæ— éœ€ç­‰å¾…ç¨³å®šï¼Œç«‹å³å¼€å§‹åŠ›æ§åˆ¶ï¼
        }
        break;
        
      case CIRCULAR_MOTION:
        // æŒç»­åœ†å‘¨è¿åŠ¨ + åŠ›åé¦ˆæ§åˆ¶ï¼ˆDSä¼˜åŠ¿ï¼šç¨³å®šæ— æŒ¯è¡ï¼‰
        break;
    }
  }
};

// ========== å§¿æ€æ§åˆ¶DSï¼ˆæ–°å¢ç»„ä»¶ï¼‰ ==========
class OrientationDS {
private:
  double stiffness_;  // å§¿æ€åˆšåº¦
  
public:
  OrientationDS(double stiffness) : stiffness_(stiffness) {}
  
  Eigen::Vector3d computeAngularVelocity(const Eigen::Vector4d& current_quat,
                                        const Eigen::Vector4d& desired_quat) {
    // åŸºäºå››å…ƒæ•°è¯¯å·®çš„å§¿æ€DS
    Eigen::Vector4d quat_error = DSUtils::quaternionProduct(
        DSUtils::quaternionInverse(current_quat), desired_quat);
    
    // è½¬æ¢ä¸ºè½´è§’è¡¨ç¤º
    Eigen::Vector3d axis;
    double angle;
    DSUtils::quaternionToAxisAngle(quat_error, axis, angle);
    
    // DSæ§åˆ¶å¾‹ï¼šÏ‰ = -k * Î¸ * n
    return -stiffness_ * angle * axis;
  }
};
```

#### 1.3.2 æ¶æ„ä¼˜åŠ¿æ€»ç»“

**ç›¸æ¯”åŸæœ‰åˆ†æ•£è®¾è®¡çš„æ”¹è¿›**ï¼š

1. **æ¶ˆé™¤é‡å¤ä»£ç **ï¼š
   - ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç† (`DSRobotState`)
   - ç»Ÿä¸€çš„èƒ½é‡ç½è®¡ç®— (`EnergyTankManager`)
   - ç»Ÿä¸€çš„DSåŸè¯­æ¥å£ (`DSPrimitive`)

2. **æé«˜å¯ç»´æŠ¤æ€§**ï¼š
   - å•ä¸€æ§åˆ¶å™¨ (`UnifiedDSController`) æ›¿ä»£å¤šä¸ªåˆ†æ•£æ§åˆ¶å™¨
   - å…±ç”¨å·¥å…·ç±» (`DSUtils`) é¿å…é‡å¤å®ç°
   - æ¸…æ™°çš„ç»„ä»¶åˆ†ç¦»å’Œæ¥å£å®šä¹‰

3. **ç¬¦åˆDSå¼€æºä»£ç æ¨¡å¼**ï¼š
   - å€Ÿé‰´Utilså·¥å…·ç±»è®¾è®¡
   - ä¿æŒèƒ½é‡ç½æ— æºæ€§è®¡ç®—çš„ç»Ÿä¸€æ€§
   - ç»´æŒDSåŸè¯­çš„æ•°å­¦çº¯ç²¹æ€§

4. **æ˜“äºæ‰©å±•**ï¼š
   - æ–°å¢DSåŸè¯­åªéœ€ç»§æ‰¿ `DSPrimitive`
   - æ–°å¢æ§åˆ¶é˜¶æ®µåªéœ€ä¿®æ”¹çŠ¶æ€æœº
   - å·¥å…·å‡½æ•°é›†ä¸­ç®¡ç†ä¾¿äºå¤ç”¨

### 1.6 å®ç°æ­¥éª¤é‡æ–°è§„åˆ’

#### ç¬¬ä¸€æ­¥ï¼šåŸºç¡€ç»„ä»¶æ¡†æ¶ + æ‰°åŠ¨æ¢å¤éªŒè¯ (1å‘¨)
1. **å®ç°ç»Ÿä¸€åŸºç¡€ç±»**ï¼š
   ```cpp
   // å…³é”®ç»„ä»¶æ¸…å•
   class DSRobotState;           // ç»Ÿä¸€çŠ¶æ€ç®¡ç†
   class EnergyTankManager;      // ç»Ÿä¸€èƒ½é‡ç½ + æ— æºæ€§
   class DisturbanceRecoveryManager;  // æ‰°åŠ¨æ¢å¤
   class DSUtils;                // å·¥å…·å‡½æ•°é›†åˆ
   class OrientationDS;          // å§¿æ€æ§åˆ¶DS
   ```

2. **åˆ›å»ºå‚æ•°åŒ–é…ç½®æ–‡ä»¶**ï¼š
   ```yaml
   # config/unified_ds_params.yaml
   ds_params:
     # çº¿æ€§DSå‚æ•°
     linear_lambda: 2.0                    # æ”¶æ•›ç‡
     linear_max_velocity: 0.05             # æœ€å¤§çº¿é€Ÿåº¦ [m/s]
     
     # åœ†å‘¨DSå‚æ•°ï¼ˆè§£å†³åŠå¾„é…ç½®çŸ›ç›¾ï¼‰
     circular_radius: 0.025                # åœ†å‘¨åŠå¾„ [m] (2.5cm vs 7.5cmå¯é…ç½®)
     circular_omega: 3.14159               # è§’é€Ÿåº¦ [rad/s]
     
     # æ¥è§¦æ£€æµ‹å‚æ•°
     contact_force_threshold: 0.3          # æ¥è§¦åŠ›é˜ˆå€¼ [N]
     exploration_speed: 0.001              # ä¸‹æ¢é€Ÿåº¦ [m/s] (1mm/s)
     
     # èƒ½é‡ç½å‚æ•°
     energy_tank_max: 4.0                  # æœ€å¤§èƒ½é‡ [J]
     energy_dissipation_rate: 1.0          # è€—æ•£ç‡
     
     # å§¿æ€æ§åˆ¶å‚æ•°
     enable_orientation_control: true       # å¯ç”¨å§¿æ€æ§åˆ¶
     orientation_stiffness: 5.0             # å§¿æ€åˆšåº¦
   ```

3. **åˆ›å»ºé›†æˆLaunchæ–‡ä»¶**ï¼š
   ```xml
   <!-- launch/unified_ds_controller.launch -->
   <?xml version="1.0" ?>
   <launch>
     <!-- æœºå™¨äººåŸºç¡€å‚æ•° -->
     <arg name="robot" default="panda" />
     <arg name="arm_id" default="$(arg robot)" />
     <arg name="robot_ip" default="172.16.0.2" />
     <arg name="load_gripper" default="false" />
     
     <!-- DSæ§åˆ¶å™¨å‚æ•°é…ç½® -->
     <rosparam file="$(find franka_ds)/config/unified_ds_params.yaml" command="load" />
     
     <!-- å¯åŠ¨Frankaæ§åˆ¶ -->
     <include file="$(find franka_control)/launch/franka_control.launch">
       <arg name="robot_ip" value="$(arg robot_ip)" />
       <arg name="load_gripper" value="$(arg load_gripper)" />
     </include>
     
     <!-- å¯åŠ¨ç°æœ‰force_sensor_readerèŠ‚ç‚¹ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰ -->
     <node name="force_sensor_reader" pkg="franka_ds" type="force_sensor_read" output="screen">
       <param name="baudrate" value="921600" />
       <param name="frequency" value="1000" />
       <param name="publish_frequency" value="100" />
     </node>
     
     <!-- å¯åŠ¨DSæ§åˆ¶å™¨ -->
     <node name="unified_ds_controller" pkg="controller_manager" type="spawner" 
           respawn="false" output="screen" 
           args="unified_ds_controller" />
     
     <!-- ç”¨æˆ·å‘½ä»¤æ¥å£ï¼ˆæ›¿ä»£é”®ç›˜è¾“å…¥ï¼‰ -->
     <node name="ds_user_interface" pkg="franka_ds" type="ds_user_interface.py" output="screen" />
     
     <!-- å¯é€‰ï¼šå¯åŠ¨RVizå¯è§†åŒ– -->
     <node name="rviz" pkg="rviz" type="rviz" output="log" 
           args="-d $(find franka_ds)/launch/robot.rviz" if="$(arg rviz)" />
   </launch>
   ```

4. **éªŒè¯Frankaé€Ÿåº¦æ§åˆ¶ + æ‰°åŠ¨æ¢å¤**ï¼š
   ```cpp
   // æ‰°åŠ¨æ¢å¤æµ‹è¯•ç¨‹åº
   void testDisturbanceRecovery() {
       // 1. è®¾å®šç®€å•ç›®æ ‡ç‚¹
       Vector3d target(0.5, 0.0, 0.3);
       
       // 2. å¯åŠ¨çº¿æ€§DSè¿åŠ¨
       LinearDS linear_ds(lambda_matrix, max_velocity);
       
       // 3. äººä¸ºæ–½åŠ æ‰°åŠ¨ï¼ˆæ‰‹æ¨æœºæ¢°è‡‚ï¼‰
       // 4. éªŒè¯DSè‡ªåŠ¨æ¢å¤åˆ°ç›®æ ‡
       // 5. æµ‹é‡æ¢å¤æ—¶é—´å’Œè½¨è¿¹å¹³æ»‘åº¦
   }
   ```

#### ç¬¬äºŒæ­¥ï¼šè‡ªç”±ç©ºé—´ä¸æ¥è§¦ç©ºé—´DSåŸè¯­ (1å‘¨)  
1. **å®ç°è‡ªç”±ç©ºé—´DSåŸè¯­**ï¼š
   ```cpp
   class FreeSpaceDS : public DSPrimitive {
       // æ ¸å¿ƒåŠŸèƒ½ï¼š
       // - çº¿æ€§æ”¶æ•›åˆ°ç›®æ ‡ç‚¹
       // - æ¥è¿‘è¡¨é¢æ—¶çš„æ··åˆDSï¼ˆæ°´å¹³+å‚ç›´ï¼‰
       // - è‡ªåŠ¨æ‰°åŠ¨æ¢å¤ï¼ˆDSå¤©ç„¶ä¼˜åŠ¿ï¼‰
   };
   
   class AdaptiveSurfaceDS : public DSPrimitive {
       // æ ¸å¿ƒåŠŸèƒ½ï¼š
       // - æœªçŸ¥è¡¨é¢ä½ç½®çš„æ¢ç´¢æ€§ä¸‹æ¢
       // - æ¥è§¦æ£€æµ‹ä¸è¡¨é¢ä½ç½®è®°å½•
       // - æ¢ç´¢é˜¶æ®µçš„æƒé‡æ··åˆç­–ç•¥
   };
   ```

2. **å®ç°æ¥è§¦ç©ºé—´DSåŸè¯­**ï¼š
   ```cpp
   class ContactDS : public DSPrimitive {
       // æ ¸å¿ƒåŠŸèƒ½ï¼š
       // - åœ†å‘¨è¿åŠ¨DSï¼ˆå‚è€ƒSurfacePolishing.cppï¼‰
       // - åŠ›åé¦ˆè°ƒåˆ¶ï¼ˆè®ºæ–‡Eq.7ï¼‰
       // - æ³•å‘é‡ä¼°è®¡ä¸åŠ›æ§åˆ¶
   };
   ```

3. **å‚æ•°è°ƒä¼˜å·¥å…·**ï¼š
   ```bash
   # åŠ¨æ€å‚æ•°è°ƒæ•´å·¥å…·
   rosrun rqt_reconfigure rqt_reconfigure
   # å¯å®æ—¶è°ƒæ•´ï¼šåœ†å‘¨åŠå¾„ã€æ”¶æ•›ç‡ã€åŠ›é˜ˆå€¼ç­‰å‚æ•°
   ```

#### ç¬¬ä¸‰æ­¥ï¼šç»Ÿä¸€æ§åˆ¶å™¨é›†æˆ + èƒ½é‡ç½éªŒè¯ (1å‘¨)
1. **å®ç°UnifiedDSController**ï¼š
   ```cpp
   class UnifiedDSController {
       // é›†æˆå®Œæ•´æ•°æ®æµï¼š
       // ä¼ æ„Ÿå™¨â†’çŠ¶æ€ä¼°è®¡â†’DSè®¡ç®—â†’èƒ½é‡çº¦æŸâ†’Frankaå‘½ä»¤
       
       // æ ¸å¿ƒæ–¹æ³•ï¼š
       Vector3d computeUnifiedDS(state, contact);
       void updateControlPhase(state, contact);
       void handleDisturbanceRecovery(external_force);
       Vector3d computeOrientationControl(current_quat, desired_quat);  // æ–°å¢
   };
   ```

2. **ç”¨æˆ·æ¥å£è„šæœ¬**ï¼š
   ```python
   #!/usr/bin/env python3
   # scripts/ds_user_interface.py
   import rospy
   from std_msgs.msg import String
   
   def main():
       rospy.init_node('ds_user_interface')
       pub = rospy.Publisher('/unified_ds/user_command', String, queue_size=1)
       
       print("DSæ§åˆ¶å™¨ç”¨æˆ·ç•Œé¢")
       print("è¾“å…¥ 'start' å¼€å§‹è¿åŠ¨ï¼Œ'stop' åœæ­¢è¿åŠ¨")
       
       while not rospy.is_shutdown():
           cmd = input("å‘½ä»¤: ").strip().lower()
           if cmd in ['start', 'stop', 'pause', 'resume']:
               msg = String()
               msg.data = cmd
               pub.publish(msg)
               print(f"å‘é€å‘½ä»¤: {cmd}")
   
   if __name__ == '__main__':
       main()
   ```

3. **èƒ½é‡ç½æ— æºæ€§éªŒè¯**ï¼š
   ```cpp
   // èƒ½é‡ç½æµ‹è¯•åœºæ™¯
   void testEnergyTankPassivity() {
       // 1. è®¾ç½®è¾ƒå°çš„èƒ½é‡å®¹é‡
       energy_tank_->setMaxEnergy(1.0);  // 1J
       
       // 2. æ‰§è¡Œé«˜åŠŸç‡è¿åŠ¨ï¼ˆå¿«é€Ÿåœ†å‘¨ï¼‰
       // 3. éªŒè¯èƒ½é‡è€—å°½æ—¶çš„å®‰å…¨åœæ­¢
       // 4. éªŒè¯èƒ½é‡æ¢å¤åçš„è¿åŠ¨é‡å¯
       // 5. æµ‹é‡åŠŸç‡æµå’Œèƒ½é‡å¹³è¡¡
   }
   ```

#### ç¬¬å››æ­¥ï¼šå®Œæ•´ç³»ç»Ÿå¯¹æ¯”éªŒè¯ + æ–‡æ¡£å®Œå–„ (1å‘¨)
1. **æ€§èƒ½å¯¹æ¯”æµ‹è¯•**ï¼š
   ```cpp
   // å¯¹æ¯”æµ‹è¯•åœºæ™¯
   struct PerformanceMetrics {
       double trajectory_accuracy;      // è½¨è¿¹ç²¾åº¦
       double disturbance_recovery_time; // æ‰°åŠ¨æ¢å¤æ—¶é—´
       double energy_efficiency;        // èƒ½é‡æ•ˆç‡
       double contact_force_stability;  // æ¥è§¦åŠ›ç¨³å®šæ€§
       double orientation_tracking_error; // å§¿æ€è·Ÿè¸ªè¯¯å·®ï¼ˆæ–°å¢ï¼‰
   };
   
   // æµ‹è¯•1ï¼šæ— æ‰°åŠ¨æƒ…å†µä¸‹çš„åŸºç¡€æ€§èƒ½
   PerformanceMetrics testBasicPerformance();
   
   // æµ‹è¯•2ï¼šæœ‰æ‰°åŠ¨æƒ…å†µä¸‹çš„é²æ£’æ€§
   PerformanceMetrics testRobustness();
   
   // æµ‹è¯•3ï¼šæ¥è§¦åŠ›æ§åˆ¶ç²¾åº¦
   PerformanceMetrics testForceControl();
   
   // æµ‹è¯•4ï¼šå§¿æ€æ§åˆ¶ç²¾åº¦ï¼ˆæ–°å¢ï¼‰
   PerformanceMetrics testOrientationControl();
   ```

2. **ä¸åŸç³»ç»ŸåŠŸèƒ½å¯¹ç­‰éªŒè¯**ï¼š
```bash
   # æµ‹è¯•å‘½ä»¤å¯¹æ¯”
   # åŸç³»ç»Ÿï¼š
   roslaunch franka_ds contact_controller.launch
   
   # DSç³»ç»Ÿï¼š
   roslaunch franka_ds unified_ds_controller.launch
   
   # éªŒè¯é¡¹ç›®ï¼š
   # - ç›¸åŒçš„è¿åŠ¨è½¨è¿¹ï¼ˆèµ·ç‚¹â†’ç›®æ ‡â†’æ¥è§¦â†’åœ†å‘¨ï¼‰
   # - ç›¸åŒçš„æ¥è§¦åŠ›æ§åˆ¶æ•ˆæœ
   # - æ›´å¼ºçš„æ‰°åŠ¨æ¢å¤èƒ½åŠ›ï¼ˆDSä¼˜åŠ¿ï¼‰
   # - æ›´å¥½çš„èƒ½é‡ç®¡ç†ï¼ˆèƒ½é‡ç½ä¿è¯ï¼‰
   # - æ›´ç²¾ç¡®çš„å§¿æ€æ§åˆ¶ï¼ˆæ–°å¢åŠŸèƒ½ï¼‰
   ```

3. **å®Œå–„ç³»ç»Ÿæ–‡æ¡£**ï¼š
   ```markdown
   # æ›´æ–° æ—§ç‰ˆæœ¬ç®—æ³•é€»è¾‘å’Œè¦æ±‚.md
   ## DSç³»ç»Ÿæ”¹è¿›è¯´æ˜
   
   ### æ€§èƒ½æå‡ï¼š
   1. å“åº”é€Ÿåº¦æå‡ï¼šæ— éœ€10ç§’ç­‰å¾…ï¼Œç«‹å³å¯åŠ¨åŠ›æ§åˆ¶
   2. æ‰°åŠ¨æ¢å¤èƒ½åŠ›ï¼š<2ç§’è‡ªåŠ¨æ¢å¤ï¼Œæ— éœ€äººå·¥å¹²é¢„
   3. å‚æ•°åŒ–é…ç½®ï¼šæ”¯æŒåŠ¨æ€è°ƒæ•´ï¼Œè§£å†³åŠå¾„é…ç½®çŸ›ç›¾
   4. å§¿æ€æ§åˆ¶ï¼šæ–°å¢æœ«ç«¯å§¿æ€ä¿æŒåŠŸèƒ½
   5. èƒ½é‡å®‰å…¨ï¼šèƒ½é‡ç½ä¿è¯æ— æºæ€§ï¼Œæå‡å®‰å…¨æ€§
   
   ### å…¼å®¹æ€§ä¿è¯ï¼š
   1. å¤ç”¨ç°æœ‰force_sensor_readerèŠ‚ç‚¹
   2. ä¿æŒç›¸åŒçš„å¯åŠ¨å‘½ä»¤æ ¼å¼
   3. ç›¸åŒçš„åŠŸèƒ½è¾“å‡ºå’Œè¿åŠ¨è½¨è¿¹
   ```

### 1.7 å…³é”®éªŒè¯æŒ‡æ ‡

#### 1.7.1 æ‰°åŠ¨æ¢å¤èƒ½åŠ›æµ‹è¯•
```
æµ‹è¯•åœºæ™¯               DSç³»ç»Ÿé¢„æœŸè¡¨ç°              åŸç³»ç»Ÿå¯¹æ¯”
å°æ‰°åŠ¨(<1N)           è‡ªåŠ¨æ¢å¤ï¼Œæ— éœ€å¹²é¢„            å¯èƒ½éœ€è¦é‡æ–°è§„åˆ’
ä¸­æ‰°åŠ¨(1-5N)          å‡é€Ÿä½†ç»§ç»­ï¼Œå¹³æ»‘æ¢å¤          åœæ­¢å¹¶é‡æ–°è§„åˆ’
å¤§æ‰°åŠ¨(>5N)           å®‰å…¨åœæ­¢ï¼Œä¿æŒæ”¶æ•›æ–¹å‘        ç´§æ€¥åœæ­¢ï¼Œéœ€æ‰‹åŠ¨é‡å¯

æ¢å¤æ—¶é—´ç›®æ ‡ï¼š<2ç§’è‡ªåŠ¨å›åˆ°æ­£å¸¸è½¨è¿¹
æ¢å¤ç²¾åº¦ç›®æ ‡ï¼šæœ€ç»ˆä½ç½®è¯¯å·®<5mm
```

#### 1.7.2 è‡ªç”±ç©ºé—´-æ¥è§¦ç©ºé—´è¡”æ¥æµ‹è¯•
```
è¡”æ¥ç‚¹               æµ‹è¯•æŒ‡æ ‡                    æœŸæœ›ç»“æœ
æ¥è¿‘è¡¨é¢            é€Ÿåº¦å¹³æ»‘åº¦                   åŠ é€Ÿåº¦å˜åŒ–<0.1m/sÂ²
æ¥è§¦ç¬é—´            åŠ›å†²å‡»å¤§å°                   å³°å€¼åŠ›<1N
æ¥è§¦ç¨³å®š            åŠ›æ§åˆ¶ç²¾åº¦                   åŠ›è¯¯å·®<Â±0.1N
åœ†å‘¨è¿åŠ¨            è½¨è¿¹åœ†åº¦                     åŠå¾„è¯¯å·®<2mm
```

#### 1.7.3 èƒ½é‡ç½æ— æºæ€§éªŒè¯
```
æµ‹è¯•æ¡ä»¶             æ— æºæ€§æŒ‡æ ‡                  å®‰å…¨ä¿è¯
èƒ½é‡å……è¶³             æ­£å¸¸è¿åŠ¨                    åŠŸç‡å¹³è¡¡ç»´æŒ
èƒ½é‡ä¸è¶³             è‡ªåŠ¨é™é€Ÿ                    åŠŸç‡æµâ‰¤0
èƒ½é‡è€—å°½             å®‰å…¨åœæ­¢                    è¿åŠ¨å®Œå…¨åœæ­¢
å¤–åŠ›å†²å‡»             èƒ½é‡å¸æ”¶                    ç³»ç»Ÿç¨³å®šæ€§ä¿æŒ
```

### 1.8 æˆåŠŸæ ‡å‡†

#### DSæ§åˆ¶ç³»ç»Ÿå®Œå…¨æ›¿ä»£ä½ç½®æ§åˆ¶ç³»ç»Ÿï¼Œå®ç°ï¼š
- âœ… **ç›¸åŒåŠŸèƒ½**ï¼šå®Œæˆä¸åŸç³»ç»Ÿç›¸åŒçš„è¿åŠ¨ä»»åŠ¡
- âœ… **æ›´å¼ºé²æ£’æ€§**ï¼šæ‰°åŠ¨æ¢å¤æ—¶é—´<2ç§’ï¼Œæ— éœ€é‡è§„åˆ’
- âœ… **æ— æºæ€§ä¿è¯**ï¼šèƒ½é‡ç½ç¡®ä¿ç³»ç»Ÿå®‰å…¨ï¼Œæ— åŠŸç‡è¿è§„
- âœ… **å¹³æ»‘è¡”æ¥**ï¼šè‡ªç”±ç©ºé—´ä¸æ¥è§¦ç©ºé—´æ— ç¼åˆ‡æ¢
- âœ… **ä»£ç ç®€æ´æ€§**ï¼šç»Ÿä¸€æ¶æ„ï¼Œå‡å°‘50%ä»£ç é‡å¤ 
# Franka DS - 三阶段渐进构建计划 (修正版)

## 📋 总体架构概述

基于论文《接触任务中的运动和力生成：一种动力学系统方法》的核心发现：**DS系统是纯速度控制，无需位置积分**。将现有的位置控制系统完全迁移到DS速度控制框架。

```
阶段一: DS纯速度控制框架 + Franka速度接口集成    🎯 当前目标
阶段二: 表面学习与法向量估计集成                📋 规划阶段  
阶段三: 完整DS调制算法与工业级优化              🔮 最终目标
```

---

## 🚀 阶段一：DS纯速度控制框架 + Franka速度接口集成 🎯

### 1.1 核心架构重新设计

#### 1.1.0 DS理论优势与性能提升说明 ⭐

**DS方法相对传统PD控制的根本优势**：

```
传统PD位置控制 (旧系统):
  控制目标: 位置误差 → PD调节 → 位置输出
  力控制策略: 间接控制（调整Z轴位置来控制接触力）
  扰动处理: 需要重新规划轨迹，响应慢
  状态切换: 需要等待时间确保稳定（如10秒等待）

DS速度控制 (新系统):
  控制目标: 当前状态 → DS计算 → 速度输出  
  力控制策略: 直接调制速度 v_d = λ*f(x) + (γ_p*F_d/d1)*e1
  扰动处理: 瞬时重新计算，自然恢复
  状态切换: 无需等待，立即响应
```

**性能提升预期**：
- ✅ **响应速度提升**：DS无需等待稳定，立即启动力反馈控制
- ✅ **控制精度提升**：直接速度调制比间接位置控制更准确
- ✅ **鲁棒性提升**：扰动后自动恢复，无需重规划
- ✅ **理论保证**：DS全局渐近稳定性，能量罐无源性保证

#### 1.1.1 自由空间与接触空间统一向量场设计 ⭐

**核心挑战**: 如何设计统一的向量场实现从起点→目标点→接触→力控制运动的无缝衔接？

##### **DS向量场分层设计**
```python
# 伪代码：向量场统一计算框架
def computeUnifiedDS(current_position, robot_state, surface_info):
    """
    统一的DS向量场计算，自动处理自由空间与接触空间切换
    """
    # 1. 判断当前所在空间
    contact_state = detectContactState(robot_state.force, surface_info)
    
    if contact_state == FREE_SPACE:
        # 自由空间：线性收敛 + 避障
        ds_velocity = computeFreeSpaceDS(current_position)
    elif contact_state == APPROACHING_SURFACE:
        # 接近表面：混合DS（接近+下探）
        ds_velocity = computeApproachingDS(current_position, surface_info)
    elif contact_state == IN_CONTACT:
        # 接触空间：力调制DS
        ds_velocity = computeContactDS(current_position, robot_state.force)
    
    # 2. 统一的扰动恢复处理
    ds_velocity = applyDisturbanceRecovery(ds_velocity, external_force)
    
    # 3. 能量罐无源性约束
    safe_velocity = energyTank.constrainVelocity(ds_velocity)
    
    return safe_velocity
```

##### **自由空间向量场设计**
```cpp
// 伪代码：自由空间DS实现扰动恢复
class FreeSpaceDS : public DSPrimitive {
private:
    Vector3d target_position_;
    Vector3d approach_point_;    // 表面上方的接近点
    Matrix3d lambda_;           // 收敛率矩阵
    
public:
    Vector3d computeVelocity(const Vector3d& current_pos, 
                           const ExternalForce& disturbance) override {
        
        // 1. 基础线性DS：x' = -λ(x - x*)
        Vector3d error = target_position_ - current_pos;
        Vector3d nominal_ds = -lambda_ * error;
        
        // 2. 扰动恢复机制（DS理论核心优势）
        if (disturbance.magnitude() > threshold_) {
            // DS自然恢复：无需重规划，直接基于当前位置重新计算
            // 这是DS相比轨迹跟踪的最大优势！
            ROS_INFO("检测到扰动，DS自动恢复到目标");
            // DS会自动从新位置收敛到目标，无需额外处理
        }
        
        // 3. 接近表面时的混合向量场
        double distance_to_target = error.norm();
        if (distance_to_target < APPROACH_THRESHOLD) {
            // 切换到接近模式：水平接近 + 垂直下探
            Vector3d horizontal_approach = computeHorizontalApproach(current_pos);
            Vector3d vertical_descent = computeVerticalDescent(current_pos);
            
            // 权重混合：距离目标越近，下探分量越大
            double descent_weight = smoothTransition(distance_to_target);
            nominal_ds = (1.0 - descent_weight) * horizontal_approach + 
                        descent_weight * vertical_descent;
        }
        
        return nominal_ds;
    }
    
private:
    Vector3d computeHorizontalApproach(const Vector3d& pos) {
        // 水平接近：只在xy平面内收敛
        Vector3d horizontal_error = target_position_.head<2>() - pos.head<2>();
        return Vector3d(horizontal_error.x(), horizontal_error.y(), 0);
    }
    
    Vector3d computeVerticalDescent(const Vector3d& pos) {
        // 垂直下探：恒定速度向下
        return Vector3d(0, 0, -DESCENT_VELOCITY);  // -1mm/s
    }
    
    double smoothTransition(double distance) {
        // 平滑过渡函数：距离越近，下探权重越大
        return 1.0 - exp(-distance / TRANSITION_SCALE);
    }
  };
  ```

##### **接触空间向量场设计**
```cpp
// 伪代码：接触空间力调制DS
class ContactDS : public DSPrimitive {
private:
    Vector3d circle_center_;
    double target_force_;
    double radius_;
    
public:
    Vector3d computeVelocity(const Vector3d& current_pos,
                           const ForceReading& contact_force) override {
        
        // 1. 基础圆周运动DS（参考SurfacePolishing.cpp）
        Vector3d tangential_ds = computeCircularMotion(current_pos);
        
        // 2. 法向力调制（论文核心：力反馈集成）
        Vector3d normal_vector = estimateSurfaceNormal(contact_force);
        double force_error = target_force_ - contact_force.magnitude();
        
        // 3. 力调制DS公式（参考论文Eq.7）
        // v_d = v_tangential + (γ_p * F_d / d1) * n
        double force_modulation = computeForceModulation(force_error);
        Vector3d force_ds = force_modulation * normal_vector;
        
        // 4. 最终调制DS
        Vector3d modulated_ds = tangential_ds + force_ds;
        
        return modulated_ds;
    }
    
private:
    Vector3d computeCircularMotion(const Vector3d& pos) {
        // 参考SurfacePolishing.cpp:605-620行的圆周运动实现
        Vector3d rel_pos = pos - circle_center_;
        double R = rel_pos.head<2>().norm();
        double theta = atan2(rel_pos.y(), rel_pos.x());
        
        Vector3d velocity;
        velocity.x() = -(R - radius_) * cos(theta) - R * omega_ * sin(theta);
        velocity.y() = -(R - radius_) * sin(theta) + R * omega_ * cos(theta);
        velocity.z() = 0;  // 圆周运动在平面内
        
        return velocity;
    }
};
```

#### 1.1.2 扰动恢复机制的DS理论基础 ⭐

**DS相比轨迹跟踪的核心优势**：

```python
# 传统轨迹跟踪的扰动处理（复杂）
def trajectory_based_control():
    if disturbance_detected():
        # 1. 检测扰动
        # 2. 停止当前轨迹
        # 3. 重新规划轨迹
        # 4. 平滑过渡到新轨迹
        # 5. 继续执行
        pass  # 需要复杂的状态机和重规划逻辑

# DS方法的扰动处理（自然）
def ds_based_control():
    # DS天然具有扰动恢复能力！
    current_velocity = ds_function(current_position, target)
    # 无论当前位置如何变化，DS都会重新计算最优速度
    # 自动收敛回目标，无需重规划！
```

**具体实现**：
  ```cpp
class DisturbanceRecoveryManager {
public:
    Vector3d applyRecovery(const Vector3d& nominal_ds, 
                          const ExternalForce& disturbance) {
        
        if (disturbance.magnitude() > DISTURBANCE_THRESHOLD) {
            // DS理论优势：无需复杂处理，只需记录恢复开始
            recovery_start_time_ = ros::Time::now();
            ROS_INFO("扰动检测：%.3f N，DS自动恢复中...", disturbance.magnitude());
        }
        
        // DS自动从新位置重新计算收敛速度
        // 这就是DS的"全局稳定性"优势
        return nominal_ds;  // DS本身就具有扰动恢复能力！
    }
    
private:
    ros::Time recovery_start_time_;
    double DISTURBANCE_THRESHOLD = 2.0;  // 2N扰动检测阈值
  };
  ```

#### 1.1.3 能量罐无源性设计 ⭐

**解决当前系统缺失的无源性保证**：

```cpp
class EnergyTankManager {
private:
    double s_;              // 当前能量水平 [J]
    double s_max_;          // 最大能量容量 [J] 
    
    // 功率项（参考SurfacePolishing.cpp:595-623）
    double p_d_;            // 耗散功率：v^T D v
    double p_n_;            // 标称DS功率：d1 * v^T * f(x)  
    double p_f_;            // 力反馈功率：F_d * v^T * e1
    
    // 标量调节函数
    double alpha_, beta_, gamma_, gamma_p_;
    
public:
    Vector3d constrainVelocity(const Vector3d& desired_velocity,
                              const Vector3d& current_velocity,
                              const ForceReading& contact_force) {
        
        // 1. 计算各项功率（参考论文Eq.15-17）
        updatePowerTerms(desired_velocity, current_velocity, contact_force);
        
        // 2. 能量罐动力学（参考论文Eq.14）
        // ṡ = α*p_d - β*p_n - γ*p_f
        double ds_dt = alpha_ * p_d_ - beta_ * p_n_ - gamma_ * p_f_;
        
        // 3. 更新能量水平
        s_ = std::clamp(s_ + ds_dt * dt_, 0.0, s_max_);
        
        // 4. 无源性约束检查
        if (isViolatingPassivity(ds_dt)) {
            // 违反无源性：限制速度
            return applyPassivityConstraint(desired_velocity);
        }
        
        return desired_velocity;  // 安全，允许执行
    }
    
private:
    void updatePowerTerms(const Vector3d& vd, const Vector3d& v, 
                         const ForceReading& force) {
        // 参考SurfacePolishing.cpp:595-623行的具体实现
        p_d_ = v.transpose() * damping_matrix_ * v;           // 耗散功率
        p_n_ = d1_ * v.dot(nominal_ds_);                      // 标称DS功率
        p_f_ = desired_force_ * v.dot(surface_normal_);       // 力反馈功率
        
        // 更新标量函数（参考论文动态调节策略）
        updateScalarFunctions();
    }
    
    bool isViolatingPassivity(double power_flow) {
        // 检查是否违反无源性约束
        return (s_ <= 0.0) && (power_flow < 0.0);
    }
    
    Vector3d applyPassivityConstraint(const Vector3d& desired_vel) {
        // 能量不足时的安全策略
        if (s_ <= 0.0) {
            // 只允许耗散性运动
            return computeDissipativeVelocity();
        }
        
        // 按能量比例缩放
        double energy_ratio = s_ / s_max_;
        return energy_ratio * desired_vel;
    }
  };
  ```

### 1.2 数据流设计 ⭐

#### 1.2.1 完整的控制数据流
```
传感器输入 → 状态估计 → DS计算 → 能量约束 → 速度命令 → Franka执行
     ↓           ↓         ↓         ↓         ↓         ↓
  力传感器    机器人状态   向量场     能量罐    安全速度   实际运动
  位置编码器   接触检测    计算      无源性     限制      反馈
  外部扰动    表面估计    扰动恢复   功率监控   指令发送   状态更新
```

**详细数据流**：
```cpp
// 主控制循环数据流
void UnifiedDSController::update(const ros::Time& time, const ros::Duration& period) {
    
    // 1. 传感器数据获取与融合
    RobotState state = sensor_manager_->updateAllSensors();
    /*
    state.position        // 来自Franka编码器
    state.velocity        // 来自Franka速度估计  
    state.contact_force   // 来自力传感器
    state.external_force  // 来自扰动检测
    */
    
    // 2. 接触状态估计
    ContactState contact = contact_detector_->classify(state);
    /*
    contact.is_in_contact     // 是否接触
    contact.surface_normal    // 表面法向量
    contact.contact_position  // 接触点位置
    */
    
    // 3. 统一DS向量场计算
    Vector3d ds_velocity = computeUnifiedDS(state, contact);
    /*
    if (FREE_SPACE):     ds_velocity = linear_ds_->compute(...)
    if (APPROACHING):    ds_velocity = approach_ds_->compute(...)  
    if (IN_CONTACT):     ds_velocity = contact_ds_->compute(...)
    */
    
    // 4. 扰动恢复处理
    ds_velocity = disturbance_manager_->applyRecovery(ds_velocity, state.external_force);
    
    // 5. 能量罐无源性约束
    Vector3d safe_velocity = energy_tank_->constrainVelocity(ds_velocity, state);
    
    // 6. 安全限制与指令发送
    safe_velocity = DSUtils::clampVelocity(safe_velocity, MAX_VELOCITY);
    velocity_handle_->setCommand(eigenToArray(safe_velocity));
    
    // 7. 状态机更新（简化的4状态）
    updateControlPhase(state, contact);
}
```

#### 1.2.2 表面接触的渐进处理策略
  ```cpp
class SurfaceApproachManager {
public:
    ApproachStrategy planApproach(const Vector3d& current_pos, 
                                 const Vector3d& target_surface_point) {
        
        ApproachStrategy strategy;
        
        // 阶段1：自由空间线性接近
        strategy.phase1_target = target_surface_point + Vector3d(0, 0, SAFE_HEIGHT);
        strategy.phase1_ds = LinearDS(lambda_approach_, max_vel_approach_);
        
        // 阶段2：受控下探
        strategy.phase2_descent_velocity = Vector3d(0, 0, -DESCENT_SPEED);  // -1mm/s
        strategy.phase2_force_threshold = CONTACT_THRESHOLD;  // 0.3N
        
        // 阶段3：接触后稳定
        strategy.phase3_stabilization_time = 2.0;  // 2秒稳定
        
        return strategy;
    }
    
    Vector3d computeApproachDS(const Vector3d& pos, const ApproachStrategy& strategy) {
        double height_above_surface = pos.z() - target_surface_point_.z();
        
        if (height_above_surface > SAFE_HEIGHT) {
            // 自由空间：线性接近到安全高度
            return strategy.phase1_ds.computeVelocity(pos, strategy.phase1_target);
        } else {
            // 接近表面：混合运动（水平收敛 + 垂直下探）
            Vector3d horizontal_ds = computeHorizontalAlignment(pos);
            Vector3d vertical_ds = strategy.phase2_descent_velocity;
            
            // 距离表面越近，下探分量越大
            double descent_weight = computeDescentWeight(height_above_surface);
            return (1.0 - descent_weight) * horizontal_ds + descent_weight * vertical_ds;
        }
    }
  };
  ```

### 1.3 数学理论重新确认

#### 1.3.1 DS速度场的纯速度本质
**参考force_based_ds_modulation/src/SurfacePolishing.cpp:565-641行**

```cpp
// DS系统的完整数据流(无位置计算):
void SurfacePolishing::computeModulatedDS() {
  // 1. 计算调制系数λ
  float delta = std::pow(2.0f*_e1.dot(_fx)*_gammap*_Fd/_d1,2.0f) + 4.0f*std::pow(_fx.norm(),4.0f);
  float la = (-2.0f*_e1.dot(_fx)*_gammap*_Fd/_d1 + sqrt(delta)) / (2.0f*std::pow(_fx.norm(),2.0f));
  
  // 2. 计算调制后的期望速度
  _vd = la*_fx + _gammap*_Fd*_e1/_d1;
  
  // 3. 速度安全限制
  if(_vd.norm() > _velocityLimit) {
    _vd *= _velocityLimit/_vd.norm();
  }
  
  // 4. 直接发布速度命令(无积分!)
  _msgDesiredTwist.linear.x = _vd(0);
  _msgDesiredTwist.linear.y = _vd(1);
  _msgDesiredTwist.linear.z = _vd(2);
  _pubDesiredTwist.publish(_msgDesiredTwist);
}
```

#### 1.3.2 标准DS数学模型确认
```
线性DS (接近运动):
  f(x) = -λ(x - x*)
  输出: 速度向量 v ∈ ℝ³

圆周DS (抛光运动):  
  f(x) = getCircularMotionVelocity(x, center, radius)
  输出: 切向速度向量 v ∈ ℝ³

组合DS (过渡运动):
  f(x) = R * v_target  // R为旋转过渡矩阵
  输出: 混合速度向量 v ∈ ℝ³

调制DS (力反馈):
  v_d = λ*f(x) + (γ_p*F_d/d1)*e1
  输出: 最终期望速度 v_d ∈ ℝ³
```

#### 1.3.3 Franka vs KUKA控制接口对比
```
DS原始系统(KUKA LWR):
  话题: /lwr/joint_controllers/passive_ds_command_vel
  类型: geometry_msgs::Twist
  接口: passive_ds_command_vel速度控制器
  
Franka对应接口:
  接口: franka_hw::FrankaVelocityCartesianInterface  
  句柄: franka_hw::FrankaCartesianVelocityHandle
  命令: std::array<double, 6> velocity_command
```

### 1.4 关键技术问题解决方案 ⭐

#### 1.4.1 未知表面位置的DS处理策略

**问题**: 表面位置未知，需要"移动到上方→下探→接触检测"

**DS解决方案**：
```cpp
class AdaptiveSurfaceDS {
private:
    Vector3d estimated_surface_point_;  // 估计的表面位置
    bool surface_found_;               // 是否已找到表面
    
public:
    Vector3d computeAdaptiveDS(const Vector3d& current_pos, 
                              const ForceReading& force) {
        
        if (!surface_found_) {
            // 阶段1：探索性下探DS
            return computeExploratoryDS(current_pos, force);
        } else {
            // 阶段2：已知表面的接触DS
            return computeContactDS(current_pos, force);
        }
    }
    
private:
    Vector3d computeExploratoryDS(const Vector3d& pos, const ForceReading& force) {
        // 组合DS：水平收敛到目标xy + 缓慢下探z
        Vector3d horizontal_ds = computeHorizontalConvergence(pos);
        Vector3d vertical_ds = Vector3d(0, 0, -EXPLORATION_SPEED);  // -0.5mm/s慢速下探
        
        // 接触检测
        if (force.z() > CONTACT_THRESHOLD) {
            // 发现表面！记录位置并切换模式
            estimated_surface_point_ = pos;
            surface_found_ = true;
            ROS_INFO("表面发现于位置: [%.3f, %.3f, %.3f]", pos.x(), pos.y(), pos.z());
        }
        
        // 权重组合：越接近目标水平位置，下探分量越大
        double exploration_weight = computeExplorationWeight(pos);
        return (1.0 - exploration_weight) * horizontal_ds + exploration_weight * vertical_ds;
    }
    
    Vector3d computeHorizontalConvergence(const Vector3d& pos) {
        // 只在xy平面收敛到目标，z方向保持当前
        Vector3d target_xy = target_position_;
        target_xy.z() = pos.z();  // 保持当前高度
        
        Vector3d error = target_xy - pos;
        return -lambda_horizontal_ * error;
    }
    
    double computeExplorationWeight(const Vector3d& pos) {
        // 距离目标xy位置越近，下探权重越大
        Vector2d xy_error = target_position_.head<2>() - pos.head<2>();
        double xy_distance = xy_error.norm();
        
        return exp(-xy_distance / EXPLORATION_TRANSITION_SCALE);
    }
};
```

#### 1.4.2 自由空间到接触空间的平滑衔接

**关键设计**：使用**权重混合**实现平滑过渡

```cpp
class SpaceTransitionManager {
public:
    Vector3d computeTransitionDS(const Vector3d& pos, 
                               const ContactState& contact,
                               const ForceReading& force) {
        
        // 计算各空间的DS
        Vector3d free_space_ds = computeFreeSpaceDS(pos);
        Vector3d contact_ds = computeContactDS(pos, force);
        
        // 根据接触状态计算混合权重
        double contact_weight = computeContactWeight(contact, force);
        
        // 平滑混合
        Vector3d blended_ds = (1.0 - contact_weight) * free_space_ds + 
                             contact_weight * contact_ds;
        
        return blended_ds;
    }
    
private:
    double computeContactWeight(const ContactState& contact, 
                              const ForceReading& force) {
        
        if (contact.state == FREE_SPACE) {
            return 0.0;  // 纯自由空间DS
        } else if (contact.state == FIRM_CONTACT) {
            return 1.0;  // 纯接触DS
        } else {
            // 过渡阶段：基于力大小的软切换
            double force_ratio = force.magnitude() / MAX_CONTACT_FORCE;
            return std::clamp(force_ratio, 0.0, 1.0);
        }
    }
};
```

#### 1.4.3 扰动恢复的具体实现机制

**DS天然优势的技术实现**：

```cpp
class RobustDSManager {
public:
    Vector3d computeRobustDS(const Vector3d& current_pos,
                           const Vector3d& current_vel,
                           const ExternalForce& disturbance) {
        
        // 1. 标准DS计算（基于当前位置）
        Vector3d nominal_ds = ds_primitive_->computeVelocity(current_pos, target_);
        
        // 2. 扰动检测与分类
        DisturbanceType disturbance_type = classifyDisturbance(disturbance);
        
        // 3. 根据扰动类型应用不同策略
        Vector3d robust_ds = applyRobustnessStrategy(nominal_ds, disturbance_type);
        
        return robust_ds;
    }
    
private:
    DisturbanceType classifyDisturbance(const ExternalForce& force) {
        double magnitude = force.magnitude();
        
        if (magnitude < SMALL_DISTURBANCE_THRESHOLD) {
            return NO_DISTURBANCE;
        } else if (magnitude < MEDIUM_DISTURBANCE_THRESHOLD) {
            return SMALL_DISTURBANCE;  // <1N：忽略，DS自然处理
        } else if (magnitude < LARGE_DISTURBANCE_THRESHOLD) {
            return MEDIUM_DISTURBANCE; // 1-5N：减速但继续
        } else {
            return LARGE_DISTURBANCE;  // >5N：紧急停止
        }
    }
    
    Vector3d applyRobustnessStrategy(const Vector3d& nominal_ds, 
                                   DisturbanceType type) {
        switch (type) {
            case NO_DISTURBANCE:
            case SMALL_DISTURBANCE:
                // DS自然处理，无需修改
                return nominal_ds;
                
            case MEDIUM_DISTURBANCE:
                // 保持方向，降低速度
                return 0.5 * nominal_ds;
                
            case LARGE_DISTURBANCE:
                // 紧急制动，但保持朝向目标的小速度
                return 0.1 * nominal_ds.normalized() * MIN_RECOVERY_SPEED;
                
            default:
                return Vector3d::Zero();
        }
    }
};
```

### 1.5 系统架构重新设计 (基于DS开源代码模式)

#### 1.3.1 统一的基础组件架构 (消除重复代码)

**关键发现**：DS开源代码虽然有Utils工具类，但仍存在大量重复代码。我们设计统一架构避免这个问题。

```cpp
namespace franka_ds {

// ========== 基础状态管理器 (统一所有状态变量) ==========
class DSRobotState {
private:
  // 机器人状态 (统一管理)
  Eigen::Vector3d position_;           // 当前位置 _x
  Eigen::Vector3d velocity_;           // 当前速度 _v
  Eigen::Vector4d quaternion_;         // 当前四元数 _q
  Eigen::Matrix3d rotation_matrix_;    // 旋转矩阵 _wRb
  
  // 力传感器状态 (统一管理)  
  Eigen::Matrix<double,6,1> wrench_;          // 当前力/力矩
  Eigen::Matrix<double,6,1> wrench_bias_;     // 力传感器偏置
  Eigen::Matrix<double,6,1> filtered_wrench_; // 滤波后力/力矩
  double normal_force_;                       // 法向力
  double normal_distance_;                    // 法向距离
  
  // ROS接口状态
  bool first_pose_received_;
  bool first_twist_received_;
  bool wrench_bias_ok_;
  int wrench_count_;
  
public:
  // 统一的状态更新接口
  void updateRobotPose(const franka::RobotState& robot_state);
  void updateRobotWrench(const geometry_msgs::WrenchStamped::ConstPtr& msg);
  
  // 统一的状态访问接口
  const Eigen::Vector3d& getPosition() const { return position_; }
  const Eigen::Vector3d& getVelocity() const { return velocity_; }
  double getNormalForce() const { return normal_force_; }
  bool isInitialized() const { return first_pose_received_ && wrench_bias_ok_; }
};

// ========== 能量罐管理器 (统一无源性计算) ==========
class EnergyTankManager {
private:
  double s_;              // 当前能量水平
  double s_max_;          // 最大能量水平
  double alpha_, beta_, gamma_, gamma_p_;  // 标量函数
  double p_n_, p_f_, p_d_;  // 功率项
  double d_w_;            // 功率流
  double d1_;             // DS-阻抗增益
  
public:
  // 统一的能量罐更新 (消除重复代码)
  void updateTankDynamics(
      const Eigen::Vector3d& velocity,
      const Eigen::Vector3d& nominal_ds,
      const Eigen::Matrix3d& damping_matrix,
      double desired_force,
      const Eigen::Vector3d& normal_vector,
      double dt);
      
  // 统一的标量函数计算 (参考SurfacePolishing.cpp:561-592)
  void updateTankScalars();
  
  double getEnergyScaleFactor() const;
  bool isMotionAllowed(double required_power) const;
};

// ========== DS原语基类 (统一DS计算接口) ==========
class DSPrimitive {
public:
  virtual ~DSPrimitive() = default;
  virtual Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position) = 0;
  virtual bool isConverged(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position,
      double tolerance = 0.01) const = 0;
  virtual std::string getName() const = 0;
};

// ========== 具体DS原语实现 ==========
class LinearDS : public DSPrimitive {
private:
  Eigen::Matrix3d lambda_;  // 收敛率矩阵
  double max_velocity_;     // 速度限制
  
public:
  LinearDS(const Eigen::Matrix3d& lambda, double max_vel)
      : lambda_(lambda), max_velocity_(max_vel) {}
      
  Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& target_position) override {
    Eigen::Vector3d error = target_position - current_position;
    Eigen::Vector3d velocity = -lambda_ * error;
    
    // 速度限制 (参考SurfacePolishing.cpp:641行)
    if (velocity.norm() > max_velocity_) {
      velocity *= max_velocity_ / velocity.norm();
    }
    return velocity;
  }
  
  bool isConverged(const Eigen::Vector3d& current_pos,
                  const Eigen::Vector3d& target_pos,
                  double tolerance) const override {
    return (target_pos - current_pos).norm() < tolerance;
  }
  
  std::string getName() const override { return "LinearDS"; }
};

class CircularDS : public DSPrimitive {
private:
  double radius_;           // 圆周半径
  double angular_velocity_; // 角速度
  
public:
  CircularDS(double radius, double omega) 
      : radius_(radius), angular_velocity_(omega) {}
      
  Eigen::Vector3d computeVelocity(
      const Eigen::Vector3d& current_position,
      const Eigen::Vector3d& center) override {
    // 参考SurfacePolishing.cpp:605-620行的getCircularMotionVelocity实现
    Eigen::Vector3d position_rel = current_position - center;
    double R = sqrt(position_rel.x() * position_rel.x() + 
                   position_rel.y() * position_rel.y());
    double theta = atan2(position_rel.y(), position_rel.x());
    
    Eigen::Vector3d velocity;
    velocity.x() = -(R - radius_) * cos(theta) - R * angular_velocity_ * sin(theta);
    velocity.y() = -(R - radius_) * sin(theta) + R * angular_velocity_ * cos(theta);
    velocity.z() = -position_rel.z();  // 垂直方向回到平面
    
    return velocity;
  }
  
  bool isConverged(const Eigen::Vector3d& current_pos,
                  const Eigen::Vector3d& center,
                  double tolerance) const override {
    Eigen::Vector3d pos_rel = current_pos - center;
    double current_radius = sqrt(pos_rel.x() * pos_rel.x() + pos_rel.y() * pos_rel.y());
    return abs(current_radius - radius_) < tolerance && abs(pos_rel.z()) < tolerance;
  }
  
  std::string getName() const override { return "CircularDS"; }
};

// ========== 工具类 (参考DS开源的Utils.h模式) ==========
class DSUtils {
public:
  // 平滑衰减函数 (参考Utils::smoothFall)
  static double smoothFall(double x, double a, double b) {
    if (x < a) return 1.0;
    if (x > b) return 0.0;
    return 0.5 * (1.0 + cos(M_PI * (x - a) / (b - a)));
  }
  
  // 速度安全限制
  static Eigen::Vector3d clampVelocity(const Eigen::Vector3d& velocity, double max_vel) {
    if (velocity.norm() > max_vel) {
      return velocity * (max_vel / velocity.norm());
    }
    return velocity;
  }
  
  // 四元数工具函数 (参考Utils类)
  static Eigen::Matrix3d quaternionToRotationMatrix(const Eigen::Vector4d& q);
  static Eigen::Vector4d rotationMatrixToQuaternion(const Eigen::Matrix3d& R);
  static Eigen::Vector4d slerpQuaternion(const Eigen::Vector4d& q1, 
                                        const Eigen::Vector4d& q2, double t);
};

// ========== 统一的DS控制器 (消除各阶段重复逻辑) ==========
class UnifiedDSController : public controller_interface::MultiInterfaceController<
    franka_hw::FrankaVelocityCartesianInterface,
    franka_hw::FrankaStateInterface> {
    
private:
  // 统一的状态管理
  std::unique_ptr<DSRobotState> robot_state_manager_;
  std::unique_ptr<EnergyTankManager> energy_tank_manager_;
  
  // DS原语集合 (避免分散的实现)
  std::unique_ptr<LinearDS> linear_ds_;
  std::unique_ptr<CircularDS> circular_ds_;
  std::unique_ptr<OrientationDS> orientation_ds_;  // 新增：姿态控制DS
  
  // Franka速度控制接口
  franka_hw::FrankaVelocityCartesianInterface* velocity_interface_;
  std::unique_ptr<franka_hw::FrankaCartesianVelocityHandle> velocity_handle_;
  
  // ROS接口集成（与现有节点兼容）
  ros::Subscriber force_sensor_sub_;    // 订阅force_sensor_reader数据
  ros::Subscriber user_command_sub_;    // 订阅用户start指令
  
  // 控制状态
  enum ControlPhase {
    CALIBRATION,       // 校准阶段 (速度=0)
    LINEAR_APPROACH,   // 线性接近 (LinearDS)
    PROBE_DESCENT,     // 探头下探 (修正LinearDS)
    CIRCULAR_MOTION    // 圆周运动 (CircularDS)
  };
  ControlPhase current_phase_;
  
  // 参数化配置（从ROS参数服务器加载，避免硬编码）
  struct DSParameters {
    // 线性DS参数
    double linear_lambda_;           // 收敛率 (默认: 2.0)
    double linear_max_velocity_;     // 最大速度 (默认: 0.05 m/s)
    
    // 圆周DS参数  
    double circular_radius_;         // 圆周半径 (可配置: 0.025或0.075)
    double circular_omega_;          // 角速度 (默认: π rad/s)
    
    // 接触检测参数
    double contact_force_threshold_; // 接触力阈值 (默认: 0.3N)
    double exploration_speed_;       // 下探速度 (默认: 0.001 m/s)
    
    // 能量罐参数
    double energy_tank_max_;         // 最大能量 (默认: 4.0J)
    double energy_dissipation_rate_; // 耗散率
    
    // 姿态控制参数
    bool enable_orientation_control_; // 是否启用姿态控制
    double orientation_stiffness_;    // 姿态刚度
  } ds_params_;
  
  // 目标参数 (各阶段共用)
  Eigen::Vector3d target_position_;
  Eigen::Vector3d circle_center_;
  Eigen::Vector4d desired_orientation_;  // 期望姿态四元数
  
public:
  bool init(hardware_interface::RobotHW* robot_hw, ros::NodeHandle& node_handle) override {
    // 1. 初始化Franka速度控制接口
    velocity_interface_ = robot_hw->get<franka_hw::FrankaVelocityCartesianInterface>();
    if (velocity_interface_ == nullptr) {
      ROS_ERROR("无法获取Franka速度控制接口");
      return false;
    }
    
    std::string arm_id;
    if (!node_handle.getParam("arm_id", arm_id)) {
      ROS_ERROR("无法获取arm_id参数");
      return false;
    }
    
    try {
      velocity_handle_ = std::make_unique<franka_hw::FrankaCartesianVelocityHandle>(
          velocity_interface_->getHandle(arm_id + "_robot"));
    } catch (const std::exception& e) {
      ROS_ERROR_STREAM("速度控制句柄初始化失败: " << e.what());
      return false;
    }
    
    // 2. 加载参数化配置（解决硬编码问题）
    loadDSParameters(node_handle);
    
    // 3. 初始化统一组件
    robot_state_manager_ = std::make_unique<DSRobotState>();
    energy_tank_manager_ = std::make_unique<EnergyTankManager>(ds_params_.energy_tank_max_);
    
    // 4. 初始化DS原语（使用参数化配置）
    Eigen::Matrix3d lambda = Eigen::Matrix3d::Identity() * ds_params_.linear_lambda_;
    linear_ds_ = std::make_unique<LinearDS>(lambda, ds_params_.linear_max_velocity_);
    circular_ds_ = std::make_unique<CircularDS>(ds_params_.circular_radius_, ds_params_.circular_omega_);
    
    // 5. 初始化姿态控制DS（如果启用）
    if (ds_params_.enable_orientation_control_) {
      orientation_ds_ = std::make_unique<OrientationDS>(ds_params_.orientation_stiffness_);
    }
    
    // 6. 初始化ROS接口（与现有节点集成）
    setupROSInterface(node_handle);
    
    current_phase_ = CALIBRATION;
    
    ROS_INFO("UnifiedDSController初始化成功");
    ROS_INFO("参数配置: 圆周半径=%.3fm, 线性速度=%.3fm/s, 接触阈值=%.1fN", 
             ds_params_.circular_radius_, ds_params_.linear_max_velocity_, ds_params_.contact_force_threshold_);
    return true;
  }
  
  void update(const ros::Time& time, const ros::Duration& period) override {
    // 1. 统一状态更新
    franka::RobotState robot_state = velocity_handle_->getRobotState();
    robot_state_manager_->updateRobotPose(robot_state);
    
    if (!robot_state_manager_->isInitialized()) {
      // 发送零速度，等待初始化完成
      std::array<double, 6> zero_velocity = {0, 0, 0, 0, 0, 0};
      velocity_handle_->setCommand(zero_velocity);
      return;
    }
    
    // 2. 统一的DS速度计算
    Eigen::Vector3d ds_linear_velocity = computeUnifiedDSVelocity();
    Eigen::Vector3d ds_angular_velocity = Eigen::Vector3d::Zero();
    
    // 3. 姿态控制（如果启用）
    if (ds_params_.enable_orientation_control_ && orientation_ds_) {
      ds_angular_velocity = orientation_ds_->computeAngularVelocity(
          robot_state_manager_->getCurrentOrientation(),
          desired_orientation_);
    }
    
    // 4. 统一的能量罐约束
    energy_tank_manager_->updateTankDynamics(
        robot_state_manager_->getVelocity(),
        ds_linear_velocity,
        Eigen::Matrix3d::Identity() * 10.0,  // 阻尼矩阵
        5.0,  // 期望力
        Eigen::Vector3d(0, 0, 1),  // 法向量
        period.toSec());
        
    double energy_scale = energy_tank_manager_->getEnergyScaleFactor();
    Eigen::Vector3d safe_linear_velocity = energy_scale * ds_linear_velocity;
    Eigen::Vector3d safe_angular_velocity = energy_scale * ds_angular_velocity;
    
    // 5. 统一的安全限制
    safe_linear_velocity = DSUtils::clampVelocity(safe_linear_velocity, ds_params_.linear_max_velocity_);
    safe_angular_velocity = DSUtils::clampVelocity(safe_angular_velocity, 0.5);  // 0.5 rad/s角速度限制
    
    // 6. 发送完整速度命令到Franka（包含线速度+角速度）
    std::array<double, 6> velocity_command = {
        safe_linear_velocity.x(), safe_linear_velocity.y(), safe_linear_velocity.z(),
        safe_angular_velocity.x(), safe_angular_velocity.y(), safe_angular_velocity.z()
    };
    velocity_handle_->setCommand(velocity_command);
    
    // 7. 统一的状态机更新（DS优势：无需等待，立即响应）
    updateControlPhase();
  }
  
private:
  // 参数化配置加载（解决硬编码问题）
  void loadDSParameters(ros::NodeHandle& nh) {
    // 线性DS参数
    nh.param("ds_params/linear_lambda", ds_params_.linear_lambda_, 2.0);
    nh.param("ds_params/linear_max_velocity", ds_params_.linear_max_velocity_, 0.05);
    
    // 圆周DS参数（支持旧系统的两种半径配置）
    nh.param("ds_params/circular_radius", ds_params_.circular_radius_, 0.025);  // 默认2.5cm
    nh.param("ds_params/circular_omega", ds_params_.circular_omega_, M_PI);     // 默认π rad/s
    
    // 接触检测参数
    nh.param("ds_params/contact_force_threshold", ds_params_.contact_force_threshold_, 0.3);
    nh.param("ds_params/exploration_speed", ds_params_.exploration_speed_, 0.001);
    
    // 能量罐参数
    nh.param("ds_params/energy_tank_max", ds_params_.energy_tank_max_, 4.0);
    nh.param("ds_params/energy_dissipation_rate", ds_params_.energy_dissipation_rate_, 1.0);
    
    // 姿态控制参数
    nh.param("ds_params/enable_orientation_control", ds_params_.enable_orientation_control_, true);
    nh.param("ds_params/orientation_stiffness", ds_params_.orientation_stiffness_, 5.0);
    
    // 参数验证
    if (ds_params_.circular_radius_ < 0.01 || ds_params_.circular_radius_ > 0.1) {
      ROS_WARN("圆周半径 %.3f 超出合理范围[0.01, 0.1]m，使用默认值0.025m", ds_params_.circular_radius_);
      ds_params_.circular_radius_ = 0.025;
    }
  }
  
  // ROS接口设置（与现有节点集成）
  void setupROSInterface(ros::NodeHandle& nh) {
    // 订阅力传感器数据（复用现有force_sensor_reader节点）
    force_sensor_sub_ = nh.subscribe("/force_sensor/filtered_wrench", 1, 
                                   &UnifiedDSController::forceCallback, this);
    
    // 订阅用户命令（复用现有的启动机制）
    user_command_sub_ = nh.subscribe("/unified_ds/user_command", 1,
                                   &UnifiedDSController::userCommandCallback, this);
    
    ROS_INFO("ROS接口初始化完成，集成现有force_sensor_reader节点");
  }
  
  // 力传感器数据回调（与现有系统兼容）
  void forceCallback(const geometry_msgs::WrenchStamped::ConstPtr& msg) {
    robot_state_manager_->updateForceReading(*msg);
  }
  
  // 用户命令回调（替代原有的键盘输入）
  void userCommandCallback(const std_msgs::String::ConstPtr& msg) {
    if (msg->data == "start" && current_phase_ == CALIBRATION) {
      current_phase_ = LINEAR_APPROACH;
      ROS_INFO("接收到start命令，开始DS运动控制");
    }
  }
  
  // 统一的DS速度计算 (消除各阶段分散逻辑)
  Eigen::Vector3d computeUnifiedDSVelocity() {
    Eigen::Vector3d current_pos = robot_state_manager_->getPosition();
    
    switch (current_phase_) {
      case CALIBRATION:
        return Eigen::Vector3d::Zero();  // 静止
        
      case LINEAR_APPROACH:
        return linear_ds_->computeVelocity(current_pos, target_position_);
        
      case PROBE_DESCENT: {
        // 组合DS：向下探测 + 向目标接近
        Eigen::Vector3d approach_vel = linear_ds_->computeVelocity(current_pos, target_position_);
        Eigen::Vector3d descent_vel(0, 0, -ds_params_.exploration_speed_);
        return approach_vel + descent_vel;
      }
      
      case CIRCULAR_MOTION:
        // DS优势：立即启动力反馈控制，无需10秒等待！
        return circular_ds_->computeVelocity(current_pos, circle_center_);
        
      default:
        return Eigen::Vector3d::Zero();
    }
  }
  
  // 统一的状态机更新 (DS优势：立即响应，无等待时间)
  void updateControlPhase() {
    Eigen::Vector3d current_pos = robot_state_manager_->getPosition();
    
    switch (current_phase_) {
      case CALIBRATION:
        // DS优势：初始化完成即可开始，无需额外等待
        if (robot_state_manager_->isInitialized()) {
          ROS_INFO("DS系统准备就绪，等待start指令");
        }
        break;
        
      case LINEAR_APPROACH:
        if (linear_ds_->isConverged(current_pos, target_position_, 0.008)) {
          current_phase_ = PROBE_DESCENT;
          ROS_INFO("到达目标，开始探索性下探");
        }
        break;
        
      case PROBE_DESCENT:
        if (robot_state_manager_->getNormalForce() > ds_params_.contact_force_threshold_) {
          circle_center_ = current_pos;  // 以接触点为圆心
          current_phase_ = CIRCULAR_MOTION;
          ROS_INFO("检测到接触，立即启动圆周运动和力反馈控制");
          // DS优势：无需等待稳定，立即开始力控制！
        }
        break;
        
      case CIRCULAR_MOTION:
        // 持续圆周运动 + 力反馈控制（DS优势：稳定无振荡）
        break;
    }
  }
};

// ========== 姿态控制DS（新增组件） ==========
class OrientationDS {
private:
  double stiffness_;  // 姿态刚度
  
public:
  OrientationDS(double stiffness) : stiffness_(stiffness) {}
  
  Eigen::Vector3d computeAngularVelocity(const Eigen::Vector4d& current_quat,
                                        const Eigen::Vector4d& desired_quat) {
    // 基于四元数误差的姿态DS
    Eigen::Vector4d quat_error = DSUtils::quaternionProduct(
        DSUtils::quaternionInverse(current_quat), desired_quat);
    
    // 转换为轴角表示
    Eigen::Vector3d axis;
    double angle;
    DSUtils::quaternionToAxisAngle(quat_error, axis, angle);
    
    // DS控制律：ω = -k * θ * n
    return -stiffness_ * angle * axis;
  }
};
```

#### 1.3.2 架构优势总结

**相比原有分散设计的改进**：

1. **消除重复代码**：
   - 统一的状态管理 (`DSRobotState`)
   - 统一的能量罐计算 (`EnergyTankManager`)
   - 统一的DS原语接口 (`DSPrimitive`)

2. **提高可维护性**：
   - 单一控制器 (`UnifiedDSController`) 替代多个分散控制器
   - 共用工具类 (`DSUtils`) 避免重复实现
   - 清晰的组件分离和接口定义

3. **符合DS开源代码模式**：
   - 借鉴Utils工具类设计
   - 保持能量罐无源性计算的统一性
   - 维持DS原语的数学纯粹性

4. **易于扩展**：
   - 新增DS原语只需继承 `DSPrimitive`
   - 新增控制阶段只需修改状态机
   - 工具函数集中管理便于复用

### 1.6 实现步骤重新规划

#### 第一步：基础组件框架 + 扰动恢复验证 (1周)
1. **实现统一基础类**：
   ```cpp
   // 关键组件清单
   class DSRobotState;           // 统一状态管理
   class EnergyTankManager;      // 统一能量罐 + 无源性
   class DisturbanceRecoveryManager;  // 扰动恢复
   class DSUtils;                // 工具函数集合
   class OrientationDS;          // 姿态控制DS
   ```

2. **创建参数化配置文件**：
   ```yaml
   # config/unified_ds_params.yaml
   ds_params:
     # 线性DS参数
     linear_lambda: 2.0                    # 收敛率
     linear_max_velocity: 0.05             # 最大线速度 [m/s]
     
     # 圆周DS参数（解决半径配置矛盾）
     circular_radius: 0.025                # 圆周半径 [m] (2.5cm vs 7.5cm可配置)
     circular_omega: 3.14159               # 角速度 [rad/s]
     
     # 接触检测参数
     contact_force_threshold: 0.3          # 接触力阈值 [N]
     exploration_speed: 0.001              # 下探速度 [m/s] (1mm/s)
     
     # 能量罐参数
     energy_tank_max: 4.0                  # 最大能量 [J]
     energy_dissipation_rate: 1.0          # 耗散率
     
     # 姿态控制参数
     enable_orientation_control: true       # 启用姿态控制
     orientation_stiffness: 5.0             # 姿态刚度
   ```

3. **创建集成Launch文件**：
   ```xml
   <!-- launch/unified_ds_controller.launch -->
   <?xml version="1.0" ?>
   <launch>
     <!-- 机器人基础参数 -->
     <arg name="robot" default="panda" />
     <arg name="arm_id" default="$(arg robot)" />
     <arg name="robot_ip" default="172.16.0.2" />
     <arg name="load_gripper" default="false" />
     
     <!-- DS控制器参数配置 -->
     <rosparam file="$(find franka_ds)/config/unified_ds_params.yaml" command="load" />
     
     <!-- 启动Franka控制 -->
     <include file="$(find franka_control)/launch/franka_control.launch">
       <arg name="robot_ip" value="$(arg robot_ip)" />
       <arg name="load_gripper" value="$(arg load_gripper)" />
     </include>
     
     <!-- 启动现有force_sensor_reader节点（保持兼容性） -->
     <node name="force_sensor_reader" pkg="franka_ds" type="force_sensor_read" output="screen">
       <param name="baudrate" value="921600" />
       <param name="frequency" value="1000" />
       <param name="publish_frequency" value="100" />
     </node>
     
     <!-- 启动DS控制器 -->
     <node name="unified_ds_controller" pkg="controller_manager" type="spawner" 
           respawn="false" output="screen" 
           args="unified_ds_controller" />
     
     <!-- 用户命令接口（替代键盘输入） -->
     <node name="ds_user_interface" pkg="franka_ds" type="ds_user_interface.py" output="screen" />
     
     <!-- 可选：启动RViz可视化 -->
     <node name="rviz" pkg="rviz" type="rviz" output="log" 
           args="-d $(find franka_ds)/launch/robot.rviz" if="$(arg rviz)" />
   </launch>
   ```

4. **验证Franka速度控制 + 扰动恢复**：
   ```cpp
   // 扰动恢复测试程序
   void testDisturbanceRecovery() {
       // 1. 设定简单目标点
       Vector3d target(0.5, 0.0, 0.3);
       
       // 2. 启动线性DS运动
       LinearDS linear_ds(lambda_matrix, max_velocity);
       
       // 3. 人为施加扰动（手推机械臂）
       // 4. 验证DS自动恢复到目标
       // 5. 测量恢复时间和轨迹平滑度
   }
   ```

#### 第二步：自由空间与接触空间DS原语 (1周)  
1. **实现自由空间DS原语**：
   ```cpp
   class FreeSpaceDS : public DSPrimitive {
       // 核心功能：
       // - 线性收敛到目标点
       // - 接近表面时的混合DS（水平+垂直）
       // - 自动扰动恢复（DS天然优势）
   };
   
   class AdaptiveSurfaceDS : public DSPrimitive {
       // 核心功能：
       // - 未知表面位置的探索性下探
       // - 接触检测与表面位置记录
       // - 探索阶段的权重混合策略
   };
   ```

2. **实现接触空间DS原语**：
   ```cpp
   class ContactDS : public DSPrimitive {
       // 核心功能：
       // - 圆周运动DS（参考SurfacePolishing.cpp）
       // - 力反馈调制（论文Eq.7）
       // - 法向量估计与力控制
   };
   ```

3. **参数调优工具**：
   ```bash
   # 动态参数调整工具
   rosrun rqt_reconfigure rqt_reconfigure
   # 可实时调整：圆周半径、收敛率、力阈值等参数
   ```

#### 第三步：统一控制器集成 + 能量罐验证 (1周)
1. **实现UnifiedDSController**：
   ```cpp
   class UnifiedDSController {
       // 集成完整数据流：
       // 传感器→状态估计→DS计算→能量约束→Franka命令
       
       // 核心方法：
       Vector3d computeUnifiedDS(state, contact);
       void updateControlPhase(state, contact);
       void handleDisturbanceRecovery(external_force);
       Vector3d computeOrientationControl(current_quat, desired_quat);  // 新增
   };
   ```

2. **用户接口脚本**：
   ```python
   #!/usr/bin/env python3
   # scripts/ds_user_interface.py
   import rospy
   from std_msgs.msg import String
   
   def main():
       rospy.init_node('ds_user_interface')
       pub = rospy.Publisher('/unified_ds/user_command', String, queue_size=1)
       
       print("DS控制器用户界面")
       print("输入 'start' 开始运动，'stop' 停止运动")
       
       while not rospy.is_shutdown():
           cmd = input("命令: ").strip().lower()
           if cmd in ['start', 'stop', 'pause', 'resume']:
               msg = String()
               msg.data = cmd
               pub.publish(msg)
               print(f"发送命令: {cmd}")
   
   if __name__ == '__main__':
       main()
   ```

3. **能量罐无源性验证**：
   ```cpp
   // 能量罐测试场景
   void testEnergyTankPassivity() {
       // 1. 设置较小的能量容量
       energy_tank_->setMaxEnergy(1.0);  // 1J
       
       // 2. 执行高功率运动（快速圆周）
       // 3. 验证能量耗尽时的安全停止
       // 4. 验证能量恢复后的运动重启
       // 5. 测量功率流和能量平衡
   }
   ```

#### 第四步：完整系统对比验证 + 文档完善 (1周)
1. **性能对比测试**：
   ```cpp
   // 对比测试场景
   struct PerformanceMetrics {
       double trajectory_accuracy;      // 轨迹精度
       double disturbance_recovery_time; // 扰动恢复时间
       double energy_efficiency;        // 能量效率
       double contact_force_stability;  // 接触力稳定性
       double orientation_tracking_error; // 姿态跟踪误差（新增）
   };
   
   // 测试1：无扰动情况下的基础性能
   PerformanceMetrics testBasicPerformance();
   
   // 测试2：有扰动情况下的鲁棒性
   PerformanceMetrics testRobustness();
   
   // 测试3：接触力控制精度
   PerformanceMetrics testForceControl();
   
   // 测试4：姿态控制精度（新增）
   PerformanceMetrics testOrientationControl();
   ```

2. **与原系统功能对等验证**：
```bash
   # 测试命令对比
   # 原系统：
   roslaunch franka_ds contact_controller.launch
   
   # DS系统：
   roslaunch franka_ds unified_ds_controller.launch
   
   # 验证项目：
   # - 相同的运动轨迹（起点→目标→接触→圆周）
   # - 相同的接触力控制效果
   # - 更强的扰动恢复能力（DS优势）
   # - 更好的能量管理（能量罐保证）
   # - 更精确的姿态控制（新增功能）
   ```

3. **完善系统文档**：
   ```markdown
   # 更新 旧版本算法逻辑和要求.md
   ## DS系统改进说明
   
   ### 性能提升：
   1. 响应速度提升：无需10秒等待，立即启动力控制
   2. 扰动恢复能力：<2秒自动恢复，无需人工干预
   3. 参数化配置：支持动态调整，解决半径配置矛盾
   4. 姿态控制：新增末端姿态保持功能
   5. 能量安全：能量罐保证无源性，提升安全性
   
   ### 兼容性保证：
   1. 复用现有force_sensor_reader节点
   2. 保持相同的启动命令格式
   3. 相同的功能输出和运动轨迹
   ```

### 1.7 关键验证指标

#### 1.7.1 扰动恢复能力测试
```
测试场景               DS系统预期表现              原系统对比
小扰动(<1N)           自动恢复，无需干预            可能需要重新规划
中扰动(1-5N)          减速但继续，平滑恢复          停止并重新规划
大扰动(>5N)           安全停止，保持收敛方向        紧急停止，需手动重启

恢复时间目标：<2秒自动回到正常轨迹
恢复精度目标：最终位置误差<5mm
```

#### 1.7.2 自由空间-接触空间衔接测试
```
衔接点               测试指标                    期望结果
接近表面            速度平滑度                   加速度变化<0.1m/s²
接触瞬间            力冲击大小                   峰值力<1N
接触稳定            力控制精度                   力误差<±0.1N
圆周运动            轨迹圆度                     半径误差<2mm
```

#### 1.7.3 能量罐无源性验证
```
测试条件             无源性指标                  安全保证
能量充足             正常运动                    功率平衡维持
能量不足             自动限速                    功率流≤0
能量耗尽             安全停止                    运动完全停止
外力冲击             能量吸收                    系统稳定性保持
```

### 1.8 成功标准

#### DS控制系统完全替代位置控制系统，实现：
- ✅ **相同功能**：完成与原系统相同的运动任务
- ✅ **更强鲁棒性**：扰动恢复时间<2秒，无需重规划
- ✅ **无源性保证**：能量罐确保系统安全，无功率违规
- ✅ **平滑衔接**：自由空间与接触空间无缝切换
- ✅ **代码简洁性**：统一架构，减少50%代码重复 